{"version":3,"sources":["scrollManagerView.es6.js"],"names":[],"mappings":"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","file":"scrollManagerView.js","sourcesContent":["/**\n * Manages behavior and UI related to scrolling the page.\n *\n * This can be used by the UI to track pending and completed updates to\n * elements that might affect the current scroll position, such as new content\n * being injected into the DOM or being hidden/shown. When such updates occur\n * that would cause a page jump, the scroll manager will fix the scroll\n * position to counteract the jump.\n *\n * When a view is ready to make a DOM change that would impact the display or\n * size of an element, it should call\n * :js:func:`RB.ScrollManagerView.markForUpdate` before updating the element.\n * After, it should call :js:func:`RB.ScrollManagerView.markUpdates`.\n *\n * Views that create floating elements at the top of the page (such as banners)\n * should increment :js:attr:`RB.ScrollManagerView.scrollYOffset` by the height\n * of the element, and decrement it when the element goes away. This will\n * ensure that when navigating to an element through the scroll manager that\n * the height of the floating element will be taken into consideration for\n * the positioning.\n *\n * Attributes:\n *     scrollYOffset (number):\n *         The offset to add when scrolling to a target element or position.\n *         Callers should only increment or decrement this, and should never\n *         set it directly.\n */\nRB.ScrollManagerView = Backbone.View.extend({\n    /**\n     * Initialize the scroll manager.\n     */\n    initialize() {\n        this.scrollYOffset = 0;\n\n        // This is used so that unit tests can create a dummy window.\n        this.window = window;\n\n        this._updateScrollPosScheduled = false;\n        this._pendingElements = new Map();\n        this._elements = new Map();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n    },\n\n    /**\n     * Scroll to a specific element on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element to scroll to.\n     */\n    scrollToElement($el) {\n        this.scrollToPosition($el.offset().top);\n    },\n\n    /**\n     * Scroll to a specific position on the page.\n     *\n     * This will take the scroll offset into account.\n     *\n     * Args:\n     *     scrollY (number):\n     *         The Y position to scroll to.\n     */\n    scrollToPosition(scrollY) {\n        this._oldScrollY = scrollY;\n\n        /*\n         * We use this instead of a flag being passed around to functions\n         * because we might actually end up using a pre-scheduled update to\n         * the scroll position, rather than scheduling a new one.\n         */\n        this._useScrollYOffset = true;\n\n        /* Attempt to immedialely scroll to the desired position. */\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        /*\n         * Chrome (and possibly other browsers in the future) attempt to be\n         * smart about restoring the initial scroll position after the page\n         * has fully loaded. However, we want to control the position in this\n         * case (probably in response to something in the URL we're handling),\n         * so we want to disable Chrome's behavior. Fortunately, there's an\n         * API for that.\n         */\n        if ('scrollRestoration' in history) {\n            history.scrollRestoration = 'manual';\n        }\n\n        this._scheduleUpdateScrollPos(true);\n    },\n\n    /**\n     * Mark an element for update.\n     *\n     * This should be called when an element will be updated with new\n     * content/size/visibility. The current state of the element will be\n     * tracked. When the update has finished, :js:func:`markUpdated` should\n     * be called to finalize the update.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element being updated.\n     */\n    markForUpdate($el) {\n        console.assert($el.length === 1);\n\n        this._pendingElements.set($el[0], {\n            oldHeight: $el.outerHeight(),\n            oldOffset: $el.offset(),\n        });\n\n        if (this._oldScrollY === null) {\n            this._oldScrollY = this.window.pageYOffset;\n        }\n    },\n\n    /**\n     * Mark an element as having been updated.\n     *\n     * This will schedule a scroll position update, factoring in the size\n     * and position differences for the element and helping prevent a page\n     * jump if the update occurred before the current scroll position.\n     *\n     * Args:\n     *     $el (jQuery):\n     *         The element that was updated.\n     */\n    markUpdated($el) {\n        console.assert($el.length === 1);\n\n        const el = $el[0];\n        const elInfo = this._pendingElements.get(el);\n\n        elInfo.newHeight = $el.outerHeight();\n        elInfo.newOffset = $el.offset();\n\n        this._elements.set(el, elInfo);\n        this._pendingElements.delete(el);\n\n        this._scheduleUpdateScrollPos();\n    },\n\n    /**\n     * Schedule an update for the scroll position.\n     *\n     * This will schedule the scroll position to be updated to take into\n     * account any updated elements. The update will happen in the next\n     * available animation frame. Only one will ever be scheduled at a time.\n     */\n    _scheduleUpdateScrollPos() {\n        if (!this._updateScrollPosScheduled) {\n            this._updateScrollPosScheduled = true;\n\n            /*\n             * Ideally we would update the DOM and set the scroll position at\n             * the same time, synchronized, without waiting for an animation\n             * frame and preventing any kind of a jump. This would work okay\n             * in some browsers (Chrome and Firefox are pretty good at not\n             * jumping), but some -- Safari (as of 10.1), Internet Explorer\n             * (as of 11), and Edge (as of 38.14393) -- will still jump after\n             * our code executes.\n             *\n             * We can minimize that jump by performing the scroll update during\n             * an animation frame, getting it as close as possible to the DOM\n             * layout update.\n             */\n            this.window.requestAnimationFrame(\n                this._updateScrollPos.bind(this));\n        }\n    },\n\n    /**\n     * Update the scroll position to factor in any element updates.\n     *\n     * This will look for any tracked elements that have been updated\n     * earlier in the page (before the current scroll position). It will\n     * then update the scroll position to take those updates into account,\n     * helping prevent a page jump.\n     */\n    _updateScrollPos() {\n        const elInfos = [];\n\n        this._elements.forEach((elInfo, el) => {\n            /*\n             * Check if the element remained the same size. We can ignore\n             * these.\n             */\n            if (elInfo.oldHeight !== elInfo.newHeighht) {\n                elInfo.el = el;\n                elInfos.push(elInfo);\n            }\n        });\n\n        let scrollY = this._oldScrollY;\n\n        if (this._useScrollYOffset) {\n            scrollY -= this.scrollYOffset;\n        }\n\n        if (elInfos.length > 0) {\n            /* Try to put these in order by position. */\n            elInfos.sort((a, b) => a.newOffset.top - b.newOffset.top);\n\n            for (let i = 0; i < elInfos.length; i++) {\n                const elInfo = elInfos[i];\n\n                /* Check if the element precedes the current scroll position. */\n                if (elInfo.newOffset.top + elInfo.newHeight < scrollY) {\n                    scrollY += (elInfo.newHeight - elInfo.oldHeight) +\n                               (elInfo.newOffset.top - elInfo.oldOffset.top);\n                }\n            }\n        }\n\n        this.window.scrollTo(this.window.pageXOffset, scrollY);\n\n        this._elements.clear();\n        this._oldScrollY = null;\n        this._useScrollYOffset = false;\n        this._updateScrollPosScheduled = false;\n    },\n});\n\n\nRB.scrollManager = new RB.ScrollManagerView();\n"]}