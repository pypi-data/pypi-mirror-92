{"version":3,"sources":["reviewRequestEditorModel.es6.js"],"names":[],"mappings":";;AAAA;;;;;;AAMA,GAAG,mBAAH,GAAyB,SAAS,KAAT,CAAe,MAAf,CAAsB;AAC3C,cAAU;AACN,uCAA+B,EADzB;AAEN,sCAA8B,EAFxB;AAGN,6BAAqB,IAHf;AAIN,kBAAU,KAJJ;AAKN,mBAAW,CALL;AAMN,kBAAU,KANJ;AAON,yBAAiB,IAPX;AAQN,gCAAwB,EARlB;AASN,uBAAe,KATT;AAUN,0BAAkB,CAVZ;AAWN,oBAAY,KAXN;AAYN,uBAAe,IAZT;AAaN,qBAAa,IAbP;AAcN,uBAAe,KAdT;AAeN,wBAAgB,KAfV;AAgBN,6BAAqB;AAhBf,KADiC;;AAoB3C;;;AAGA,cAvB2C,wBAuB9B;AAAA;;AACT,YAAM,gBAAgB,KAAK,GAAL,CAAS,eAAT,CAAtB;;AAEA;AACA,YAAI,kBAAkB,KAAK,GAAL,CAAS,iBAAT,CAAtB;;AAEA,YAAI,oBAAoB,IAAxB,EAA8B;AAC1B,8BAAkB,IAAI,SAAS,UAAb,CAAwB,EAAxB,EAA4B;AAC1C,uBAAO,GAAG;AADgC,aAA5B,CAAlB;AAGA,iBAAK,GAAL,CAAS,iBAAT,EAA4B,eAA5B;AACH;;AAED,aAAK,QAAL,CAAc,eAAd,EAA+B,KAA/B,EACc,KAAK,kCADnB;AAEA,wBAAgB,IAAhB,CACI,KAAK,kCAAL,CAAwC,IAAxC,CAA6C,IAA7C,CADJ;;AAGA;AACA,YAAI,cAAc,KAAK,GAAL,CAAS,aAAT,CAAlB;;AAEA,YAAI,gBAAgB,IAApB,EAA0B;AACtB,0BAAc,IAAI,SAAS,UAAb,CAAwB,EAAxB,EAA4B;AACtC,uBAAO,GAAG;AAD4B,aAA5B,CAAd;AAGA,iBAAK,GAAL,CAAS,aAAT,EAAwB,WAAxB;AACH;;AAED,aAAK,QAAL,CAAc,WAAd,EAA2B,KAA3B,EACc,KAAK,kCADnB;AAEA,oBAAY,IAAZ,CACI,KAAK,kCAAL,CAAwC,IAAxC,CAA6C,IAA7C,CADJ;;AAGA;AACA,aAAK,QAAL,CAAc,cAAc,KAA5B,EAAmC,QAAnC,EACc;AAAA,mBAAM,MAAK,OAAL,CAAa,QAAb,CAAN;AAAA,SADd;AAEA,aAAK,QAAL,CAAc,cAAc,KAA5B,EAAmC,OAAnC,EACc;AAAA,mBAAM,MAAK,OAAL,CAAa,OAAb,CAAN;AAAA,SADd;AAEA,aAAK,QAAL,CAAc,aAAd,EAA6B,cAA7B,EAA6C,KAAK,gBAAlD;AACA,aAAK,gBAAL;AACH,KA/D0C;;;AAiE3C;;;;;;;;;;;;;;;;;;AAkBA,wBAnF2C,gCAmFtB,UAnFsB,EAmFV;AAC7B,YAAM,QAAQ,KAAK,GAAL,CAAS,eAAT,EAA0B,KAAxC;AACA,YAAM,kBAAkB,KAAK,GAAL,CAAS,iBAAT,CAAxB;AACA,YAAM,iBAAiB,MAAM,oBAAN,CAA2B,UAA3B,CAAvB;;AAEA,wBAAgB,GAAhB,CAAoB,cAApB;;AAEA,eAAO,cAAP;AACH,KA3F0C;;;AA6F3C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BA,iBA5H2C,yBA4H7B,SA5H6B,EA4HN;AAAA,YAAZ,OAAY,uEAAJ,EAAI;;AACjC,YAAM,gBAAgB,KAAK,GAAL,CAAS,eAAT,CAAtB;AACA,YAAM,QAAQ,cAAc,KAA5B;;AAEA,YAAI,QAAQ,YAAZ,EAA0B;AACtB,gBAAI,aAAJ;;AAEA,gBAAI,QAAQ,eAAZ,EAA6B;AACzB,oBAAM,gBAAgB,MAAM,GAAN,CAAU,eAAV,CAAtB;;AAEA,oBAAI,iBAAiB,cAAc,UAAnC,EAA+C;AAC3C,2BAAO,cAAc,UAArB;AACH;AACJ;;AAED,gBAAI,CAAC,IAAL,EAAW;AACP,uBAAO,MAAM,GAAN,CAAU,WAAV,CAAP;AACH;;AAED,mBAAO,KAAK,SAAL,CAAP;AACH,SAhBD,MAgBO,IAAI,cAAc,kBAAd,IACA,cAAc,0BADlB,EAC8C;AACjD,mBAAO,cAAc,GAAd,CAAkB,SAAlB,CAAP;AACH,SAHM,MAGA;AACH,mBAAO,MAAM,GAAN,CAAU,SAAV,CAAP;AACH;AACJ,KAtJ0C;;;AAwJ3C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA,mBAAe,uBAAS,SAAT,EAAoB,KAApB,EAA0D;AAAA;;AAAA,YAA/B,OAA+B,uEAAvB,EAAuB;AAAA,YAAnB,OAAmB,uEAAX,SAAW;;AACrE,YAAM,gBAAgB,KAAK,GAAL,CAAS,eAAT,CAAtB;AACA,YAAM,OAAO,EAAb;;AAEA,YAAI,gBAAgB,QAAQ,aAA5B;;AAEA,gBAAQ,MAAR,CACI,aADJ,EAEI,+DACU,SADV,QAFJ;;AAKA,YAAI,QAAQ,YAAZ,EAA0B;AACtB,4CAA8B,aAA9B;AACH;;AAED,YAAI,QAAQ,aAAZ,EAA2B;AACvB,gBAAI,wBAAwB,QAAQ,qBAApC;;AAEA,oBAAQ,MAAR,CAAe,qBAAf,EACe,oCADf;;AAGA,gBAAI,QAAQ,YAAZ,EAA0B;AACtB,wDAAsC,qBAAtC;AACH;;AAED,gBAAM,WAAW,CAAC,CAAC,QAAQ,QAA3B;AACA,iBAAK,qBAAL,IAA8B,WAAW,UAAX,GAAwB,OAAtD;;AAEA,iBAAK,eAAL,GAAuB,MAAvB;AACA,iBAAK,kBAAL,GAA0B,KAA1B;AACH;;AAED,aAAK,aAAL,IAAsB,KAAtB;;AAEA,sBAAc,KAAd,CAAoB,IAApB,CAAyB;AACrB,kBAAM,IADe;AAErB,mBAAO,eAAC,KAAD,EAAQ,GAAR,EAAgB;AACnB,oBAAI,UAAU,EAAd;;AAEA,uBAAK,GAAL,CAAS,YAAT,EAAuB,KAAvB;;AAEA,oBAAI,EAAE,UAAF,CAAa,QAAQ,KAArB,CAAJ,EAAiC;AAC7B,wBAAM,MAAM,IAAI,YAAhB;AACA,wBAAM,aAAa,IAAI,MAAJ,CAAW,aAAX,CAAnB;AACA,wBAAM,gBAAgB,WAAW,MAAjC;;AAEA;AACA,sBAAE,IAAF,CAAO,UAAP,EAAmB,UAAC,KAAD,EAAQ,CAAR,EAAc;AAC7B;AACA,4BAAI,MAAM,gBAAgB,CAAtB,IAA2B,gBAAgB,CAA/C,EAAkD;AAC9C,gCAAI,IAAI,CAAR,EAAW;AACP,2CAAW,IAAX;AACH;;AAED,kDAAoB,KAApB;AACH,yBAND,MAMO;AACH,gCAAI,IAAI,CAAR,EAAW;AACP,2CAAW,IAAX;AACH;;AAED,6CAAe,KAAf;AACH;AACJ,qBAfD;;AAiBA,wBAAI,cAAc,cAAlB,EAAkC;AAC9B,kCAAU,4EAGG,WAAW,MAHd,GAIN,CAAC,OAAD,CAJM,CAAV;AAKH,qBAND,MAMO,IAAI,cAAc,cAAlB,EAAkC;AACrC,kCAAU,0EAGG,WAAW,MAHd,GAIN,CAAC,OAAD,CAJM,CAAV;AAKH,qBANM,MAMA,IAAI,cAAc,WAAlB,EAA+B;AAClC,kCAAU,gDAEN,CAAC,OAAD,CAFM,CAAV;AAGH,qBAJM,MAIA,IAAI,cAAc,WAAlB,EAA+B;AAClC,kCAAU,8FAGG,WAAW,MAHd,GAIN,CAAC,OAAD,CAJM,CAAV;AAKH;;AAED,4BAAQ,KAAR,CAAc,IAAd,CAAmB,OAAnB,EAA4B;AACxB,mCAAW;AADa,qBAA5B;AAGH;AACJ,aA1DoB;AA2DrB,qBAAS,mBAAM;AACX,uBAAK,GAAL,CAAS,UAAT,EAAqB,IAArB;;AAEA,oBAAI,EAAE,UAAF,CAAa,QAAQ,OAArB,CAAJ,EAAmC;AAC/B,4BAAQ,OAAR,CAAgB,IAAhB,CAAqB,OAArB;AACH;;AAED,uBAAK,OAAL,CAAa,kBAAkB,SAA/B,EAA0C,KAA1C;AACA,uBAAK,OAAL,CAAa,cAAb,EAA6B,SAA7B,EAAwC,KAAxC;;AAEA,oBAAI,OAAK,GAAL,CAAS,YAAT,CAAJ,EAA4B;AACxB,2BAAK,IAAL,CAAU,kBAAV;;AAEA,wBAAI,OAAK,GAAL,CAAS,kBAAT,MAAiC,CAArC,EAAwC;AACpC,+BAAK,GAAL,CAAS,YAAT,EAAuB,KAAvB;AACA,+BAAK,YAAL;AACH;AACJ;AACJ;AA7EoB,SAAzB,EA8EG,IA9EH;AA+EH,KA1T0C;;AA4T3C;;;;;;;;;;;;;;;;;;;;AAoBA,gBAhV2C,0BAgVlB;AAAA;;AAAA,YAAZ,OAAY,uEAAJ,EAAI;;AACrB,YAAM,gBAAgB,KAAK,GAAL,CAAS,eAAT,CAAtB;AACA,YAAM,UAAU,SAAV,OAAU,CAAC,KAAD,EAAQ,GAAR;AAAA,mBAAgB,OAAK,OAAL,CAAa,cAAb,EAA6B,IAAI,SAAjC,CAAhB;AAAA,SAAhB;;AAEA,sBAAc,KAAd,CAAoB,aAApB,CAAkC;AAC9B,qBAAS,mBAAM;AACX,oBAAI,cAAc,UAAd,CAAyB,KAAzB,CAA+B,SAA/B,CAAyC,KAAzC,KACA,cAAc,KAAd,CAAoB,UAApB,CAA+B,KAA/B,CAAqC,SAArC,CAA+C,KADnD,EAC0D;AACtD,wBAAI,CAAC,8JAAL,EAAqK;AACjK;AACH;AACJ;AACD,8BAAc,KAAd,CAAoB,OAApB,CAA4B;AACxB,6BAAS;AAAA,+BAAM,OAAK,OAAL,CAAa,WAAb,CAAN;AAAA,qBADe;AAExB,2BAAO,OAFiB;AAGxB,6BAAS,QAAQ,OAAR,GAAkB,CAAlB,GAAsB;AAHP,iBAA5B,EAIG,MAJH;AAKH,aAb6B;AAc9B,mBAAO;AAduB,SAAlC,EAeG,IAfH;AAgBH,KApW0C;;;AAsW3C;;;;;;;;;AASA,QA/W2C,gBA+WtC,IA/WsC,EA+WhC;AACP,YAAM,QAAQ,KAAK,GAAL,CAAS,IAAT,CAAd;AACA,gBAAQ,MAAR,CAAe,EAAE,QAAF,CAAW,KAAX,CAAf;AACA,aAAK,GAAL,CAAS,IAAT,EAAe,QAAQ,CAAvB,EAA0B;AACtB,sBAAU;AADY,SAA1B;AAGH,KArX0C;;;AAuX3C;;;;;;;;;AASA,QAhY2C,gBAgYtC,IAhYsC,EAgYhC;AACP,YAAM,QAAQ,KAAK,GAAL,CAAS,IAAT,CAAd;AACA,gBAAQ,MAAR,CAAe,EAAE,QAAF,CAAW,KAAX,CAAf;AACA,aAAK,GAAL,CAAS,IAAT,EAAe,QAAQ,CAAvB,EAA0B;AACtB,sBAAU;AADY,SAA1B;AAGH,KAtY0C;;;AAwY3C;;;;;;;AAOA,YA/Y2C,oBA+YlC,KA/YkC,EA+Y3B;AACZ,YAAM,UAAU,GAAG,mBAAH,CAAuB,OAAvC;;AAEA,YAAI,EAAE,GAAF,CAAM,KAAN,EAAa,WAAb,KAA6B,MAAM,SAAN,GAAkB,CAAnD,EAAsD;AAClD,mBAAO,QAAQ,qBAAf;AACH;AACJ,KArZ0C;;;AAuZ3C;;;;;;;;;AASA,oBAha2C,8BAgaxB;AACf,YAAM,QAAQ,KAAK,GAAL,CAAS,eAAT,EAA0B,GAA1B,CAA8B,OAA9B,CAAd;AACA,YAAM,UAAW,UAAU,GAAG,aAAH,CAAiB,OAA5C;;AAEA,aAAK,GAAL,CAAS;AACL,sBAAU,KAAK,GAAL,CAAS,eAAT,KAA6B,OADlC;AAEL,4BAAgB,KAAK,GAAL,CAAS,qBAAT,KAAmC,CAAC;AAF/C,SAAT;AAIH,KAxa0C;;;AA0a3C;;;;;;;;;;AAUA,sCApb2C,8CAobR,UApbQ,EAobI;AAAA;;AAC3C,aAAK,QAAL,CAAc,UAAd,EAA0B,QAA1B,EACc;AAAA,mBAAM,OAAK,OAAL,CAAa,QAAb,CAAN;AAAA,SADd;;AAGA,aAAK,QAAL,CAAc,UAAd,EAA0B,eAA1B,EAA2C,YAAM;AAC7C,mBAAK,GAAL,CAAS,UAAT,EAAqB,IAArB;AACA,mBAAK,OAAL,CAAa,OAAb;AACH,SAHD;AAIH;AA5b0C,CAAtB,EA6btB;AACC,aAAS;AACL;AADK;AADV,CA7bsB,CAAzB","file":"reviewRequestEditorModel.js","sourcesContent":["/**\n * Handles all operations and state related to editing review requests.\n *\n * This manages the editing of all fields and objects on a review request,\n * the publishing workflow, and validation.\n */\nRB.ReviewRequestEditor = Backbone.Model.extend({\n    defaults: {\n        changeDescriptionRenderedText: '',\n        closeDescriptionRenderedText: '',\n        commentIssueManager: null,\n        editable: false,\n        editCount: 0,\n        hasDraft: false,\n        fileAttachments: null,\n        fileAttachmentComments: {},\n        mutableByUser: false,\n        pendingSaveCount: 0,\n        publishing: false,\n        reviewRequest: null,\n        screenshots: null,\n        showSendEmail: false,\n        statusEditable: false,\n        statusMutableByUser: false,\n    },\n\n    /**\n     * Initialize the editor.\n     */\n    initialize() {\n        const reviewRequest = this.get('reviewRequest');\n\n        // Set up file attachments.\n        let fileAttachments = this.get('fileAttachments');\n\n        if (fileAttachments === null) {\n            fileAttachments = new Backbone.Collection([], {\n                model: RB.FileAttachment,\n            });\n            this.set('fileAttachments', fileAttachments);\n        }\n\n        this.listenTo(fileAttachments, 'add',\n                      this._onFileAttachmentOrScreenshotAdded);\n        fileAttachments.each(\n            this._onFileAttachmentOrScreenshotAdded.bind(this));\n\n        // Set up screenshots.\n        let screenshots = this.get('screenshots');\n\n        if (screenshots === null) {\n            screenshots = new Backbone.Collection([], {\n                model: RB.Screenshot,\n            });\n            this.set('screenshots', screenshots);\n        }\n\n        this.listenTo(screenshots, 'add',\n                      this._onFileAttachmentOrScreenshotAdded);\n        screenshots.each(\n            this._onFileAttachmentOrScreenshotAdded.bind(this));\n\n        // Connect to other signals.\n        this.listenTo(reviewRequest.draft, 'saving',\n                      () => this.trigger('saving'));\n        this.listenTo(reviewRequest.draft, 'saved',\n                      () => this.trigger('saved'));\n        this.listenTo(reviewRequest, 'change:state', this._computeEditable);\n        this._computeEditable();\n    },\n\n    /**\n     * Create a file attachment tracked by the editor.\n     *\n     * This wraps RB.ReviewRequestDraft.createFileAttachment and stores the\n     * file attachment in the fileAttachments collection.\n     *\n     * This should be used instead of\n     * RB.ReviewRequestDraft.createFileAttachment for any existing or newly\n     * uploaded file attachments.\n     *\n     * Args:\n     *     attributes (object):\n     *         Model attributes for the new file attachment.\n     *\n     * Returns:\n     *     RB.FileAttachment:\n     *     The new file attachment model.\n     */\n    createFileAttachment(attributes) {\n        const draft = this.get('reviewRequest').draft;\n        const fileAttachments = this.get('fileAttachments');\n        const fileAttachment = draft.createFileAttachment(attributes);\n\n        fileAttachments.add(fileAttachment);\n\n        return fileAttachment;\n    },\n\n    /**\n     * Return a field from the draft.\n     *\n     * This will look either in the draft's data or in the extraData (for\n     * custom fields), returning the value provided either when the page\n     * was generated or when it was last edited.\n     *\n     * Args:\n     *     fieldName (string):\n     *         The name of the field to get.\n     *\n     *     options (object, optional):\n     *         Options for the operation.\n     *\n     * Option Args:\n     *     jsonFieldName (string, optional):\n     *         The key to use for the field name in the API. This is required\n     *         if ``useExtraData`` is set.\n     *\n     *     useExtraData (boolean, optional):\n     *         Whether the field is stored as part of the extraData or is a\n     *         regular attribute. This requires ``jsonFieldName`` to be set.\n     *\n     *     useRawTextValue (boolean, optional):\n     *         Whether to return the raw text value for a field. This requires\n     *         ``useExtraData`` to be set to ``true``.\n     *\n     * Returns:\n     *     *:\n     *     The value of the field.\n     */\n    getDraftField(fieldName, options={}) {\n        const reviewRequest = this.get('reviewRequest');\n        const draft = reviewRequest.draft;\n\n        if (options.useExtraData) {\n            let data;\n\n            if (options.useRawTextValue) {\n                const rawTextFields = draft.get('rawTextFields');\n\n                if (rawTextFields && rawTextFields.extra_data) {\n                    data = rawTextFields.extra_data;\n                }\n            }\n\n            if (!data) {\n                data = draft.get('extraData');\n            }\n\n            return data[fieldName];\n        } else if (fieldName === 'closeDescription' ||\n                   fieldName === 'closeDescriptionRichText') {\n            return reviewRequest.get(fieldName);\n        } else {\n            return draft.get(fieldName);\n        }\n    },\n\n    /**\n     * Set a field in the draft.\n     *\n     * If we're in the process of publishing, this will check if we have saved\n     * all fields before publishing the draft.\n     *\n     * Once the field has been saved, two events will be triggered:\n     *\n     *     * fieldChanged(fieldName, value)\n     *     * fieldChanged:<fieldName>(value)\n     *\n     * Args:\n     *     fieldName (string):\n     *         The name of the field to set.\n     *\n     *     value (*):\n     *         The value to set in the field.\n     *\n     *     options (object, optional):\n     *         Options for the set operation.\n     *\n     *     context (object, optional):\n     *         Optional context to use when calling callbacks.\n     *\n     * Option Args:\n     *     allowMarkdown (boolean, optional):\n     *         Whether the field can support rich text (Markdown).\n     *         This requires that ``jsonTextTypeFieldName`` is set.\n     *\n     *     error (function, optional):\n     *         A callback to call in case of error.\n     *\n     *     jsonFieldName (string):\n     *         The key to use for the field name in the API. This is required.\n     *\n     *     jsonTextTypeFieldName (string, optional):\n     *         The key to use for the name of the field indicating the text\n     *         type (rich text or plain) in the API.\n     *\n     *     richText (boolean, optional):\n     *         Whether the field is rich text (Markdown) formatted.\n     *\n     *     success (function, optional):\n     *         A callback to call once the field has been set successfully.\n     *\n     *     useExtraData (boolean, optional):\n     *         Whether the field should be set as a key in extraData or as a\n     *         direct attribute.\n     */\n    setDraftField: function(fieldName, value, options={}, context=undefined) {\n        const reviewRequest = this.get('reviewRequest');\n        const data = {};\n\n        let jsonFieldName = options.jsonFieldName;\n\n        console.assert(\n            jsonFieldName,\n            `jsonFieldName must be set when setting draft ` +\n            `field \"${fieldName}\".`);\n\n        if (options.useExtraData) {\n            jsonFieldName = `extra_data.${jsonFieldName}`;\n        }\n\n        if (options.allowMarkdown) {\n            let jsonTextTypeFieldName = options.jsonTextTypeFieldName;\n\n            console.assert(jsonTextTypeFieldName,\n                           'jsonTextTypeFieldName must be set.');\n\n            if (options.useExtraData) {\n                jsonTextTypeFieldName = `extra_data.${jsonTextTypeFieldName}`;\n            }\n\n            const richText = !!options.richText;\n            data[jsonTextTypeFieldName] = richText ? 'markdown' : 'plain';\n\n            data.force_text_type = 'html';\n            data.include_text_types = 'raw';\n        }\n\n        data[jsonFieldName] = value;\n\n        reviewRequest.draft.save({\n            data: data,\n            error: (model, xhr) => {\n                let message = '';\n\n                this.set('publishing', false);\n\n                if (_.isFunction(options.error)) {\n                    const rsp = xhr.errorPayload;\n                    const fieldValue = rsp.fields[jsonFieldName];\n                    const fieldValueLen = fieldValue.length;\n\n                    /* Wrap each term in quotes or a leading 'and'. */\n                    _.each(fieldValue, (value, i) => {\n                        // XXX: This method isn't localizable.\n                        if (i === fieldValueLen - 1 && fieldValueLen > 1) {\n                            if (i > 2) {\n                                message += ', ';\n                            }\n\n                            message += ` and \"${value}\"`;\n                        } else {\n                            if (i > 0) {\n                                message += ', ';\n                            }\n\n                            message += `\"${value}\"`;\n                        }\n                    });\n\n                    if (fieldName === 'targetGroups') {\n                        message = interpolate(\n                            ngettext('Group %s does not exist.',\n                                     'Groups %s do not exist.',\n                                     fieldValue.length),\n                            [message]);\n                    } else if (fieldName === 'targetPeople') {\n                        message = interpolate(\n                            ngettext('User %s does not exist.',\n                                     'Users %s do not exist.',\n                                     fieldValue.length),\n                            [message]);\n                    } else if (fieldName === 'submitter') {\n                        message = interpolate(\n                            gettext('User %s does not exist.'),\n                            [message]);\n                    } else if (fieldName === 'dependsOn') {\n                        message = interpolate(\n                            ngettext('Review Request %s does not exist.',\n                                     'Review Requests %s do not exist.',\n                                     fieldValue.length),\n                            [message]);\n                    }\n\n                    options.error.call(context, {\n                        errorText: message\n                    });\n                }\n            },\n            success: () => {\n                this.set('hasDraft', true);\n\n                if (_.isFunction(options.success)) {\n                    options.success.call(context);\n                }\n\n                this.trigger('fieldChanged:' + fieldName, value);\n                this.trigger('fieldChanged', fieldName, value);\n\n                if (this.get('publishing')) {\n                    this.decr('pendingSaveCount');\n\n                    if (this.get('pendingSaveCount') === 0) {\n                        this.set('publishing', false);\n                        this.publishDraft();\n                    }\n                }\n            }\n        }, this);\n    },\n\n    /**\n     * Publish the draft to the server.\n     *\n     * This assumes all fields have been saved.\n     *\n     * If there's an error during saving or validation, the \"publishError\"\n     * event will be triggered with the error message. Otherwise, upon\n     * success, the \"publish\" event will be triggered. However, users will\n     * have the chance to cancel the publish in the event that the submitter\n     * has been changed.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the publish operation.\n     *\n     * Option Args:\n     *     trivial (boolean):\n     *         Whether the publish is \"trivial\" (if true, no e-mail\n     *         notifications will be sent).\n     */\n    publishDraft(options={}) {\n        const reviewRequest = this.get('reviewRequest');\n        const onError = (model, xhr) => this.trigger('publishError', xhr.errorText);\n\n        reviewRequest.draft.ensureCreated({\n            success: () => {\n                if (reviewRequest.attributes.links.submitter.title !==\n                    reviewRequest.draft.attributes.links.submitter.title) {\n                    if (!confirm(gettext('Are you sure you want to change the ownership of this review request? Doing so may prevent you from editing the review request afterwards.'))) {\n                        return;\n                    }\n                }\n                reviewRequest.draft.publish({\n                    success: () => this.trigger('published'),\n                    error: onError,\n                    trivial: options.trivial ? 1 : 0\n                }, this);\n            },\n            error: onError,\n        }, this);\n    },\n\n    /**\n     * Increment an attribute by 1.\n     *\n     * The attribute must be an integer.\n     *\n     * Args:\n     *     attr (string):\n     *         The name of the attribute to increment.\n     */\n    incr(attr) {\n        const value = this.get(attr);\n        console.assert(_.isNumber(value));\n        this.set(attr, value + 1, {\n            validate: true,\n        });\n    },\n\n    /**\n     * Decrement an attribute by 1.\n     *\n     * The attribute must be an integer.\n     *\n     * Args:\n     *     attr (string):\n     *         The name of the attribute to decrement.\n     */\n    decr(attr) {\n        const value = this.get(attr);\n        console.assert(_.isNumber(value));\n        this.set(attr, value - 1, {\n            validate: true,\n        });\n    },\n\n    /**\n     * Validate the given attributes.\n     *\n     * Args:\n     *     attrs (object):\n     *         The attributes to validate.\n     */\n    validate(attrs) {\n        const strings = RB.ReviewRequestEditor.strings;\n\n        if (_.has(attrs, 'editCount') && attrs.editCount < 0) {\n            return strings.UNBALANCED_EDIT_COUNT;\n        }\n    },\n\n    /**\n     * Compute the editable state of the review request and open/close states.\n     *\n     * The review request is editable if the user has edit permissions and it's\n     * not closed.\n     *\n     * The close state and accompanying description is editable if the user\n     * has the ability to close the review request and it's currently closed.\n     */\n    _computeEditable() {\n        const state = this.get('reviewRequest').get('state');\n        const pending = (state === RB.ReviewRequest.PENDING);\n\n        this.set({\n            editable: this.get('mutableByUser') && pending,\n            statusEditable: this.get('statusMutableByUser') && !pending,\n        });\n    },\n\n    /**\n     * Handle when a FileAttachment or Screenshot is added.\n     *\n     * Listens for events on the FileAttachment or Screenshot and relays\n     * them to the editor.\n     *\n     * Args:\n     *     attachment (RB.FileAttachment or RB.Screenshot):\n     *         The new file attachment or screenshot.\n     */\n    _onFileAttachmentOrScreenshotAdded(attachment) {\n        this.listenTo(attachment, 'saving',\n                      () => this.trigger('saving'));\n\n        this.listenTo(attachment, 'saved destroy', () => {\n            this.set('hasDraft', true);\n            this.trigger('saved');\n        });\n    },\n}, {\n    strings: {\n        UNBALANCED_EDIT_COUNT:\n            gettext('There is an internal error balancing the edit count'),\n    },\n});\n"]}