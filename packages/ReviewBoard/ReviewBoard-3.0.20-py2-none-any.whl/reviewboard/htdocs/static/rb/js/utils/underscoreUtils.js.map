{"version":3,"sources":["underscoreUtils.es6.js"],"names":[],"mappings":";;;;AAAA;;;;;;;;;;;;;;;;;;;;;;AAsBA,EAAE,aAAF,GAAkB,UAAS,SAAT,EAAoB,OAApB,EACuD;AAAA,QAA9C,WAA8C,uEAAlC,CAAC,SAAD,EAAY,OAAZ,EAAqB,UAArB,CAAkC;;AACrE,QAAI,CAAC,OAAL,EAAc;AACV,eAAO,SAAP;AACH;;AAED,QAAM,mBAAmB,EAAzB;;AALqE;AAAA;AAAA;;AAAA;AAOrE,6BAAyB,OAAO,OAAP,CAAe,SAAf,CAAzB,8HAAoD;AAAA;AAAA,gBAA1C,GAA0C;AAAA,gBAArC,KAAqC;;AAChD,gBAAI,YAAY,QAAZ,CAAqB,GAArB,KAA6B,EAAE,UAAF,CAAa,KAAb,CAAjC,EAAsD;AAClD,iCAAiB,GAAjB,IAAwB,EAAE,IAAF,CAAO,KAAP,EAAc,OAAd,CAAxB;AACH;AACJ;AAXoE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAarE,WAAO,EAAE,QAAF,CAAW,gBAAX,EAA6B,SAA7B,CAAP;AACH,CAfD;;AAkBA;;;;;;;;;;;;;;AAcA,EAAE,QAAF,GAAa,UAAS,IAAT,EAAe;AACxB,WAAO,YAAM;AACT,UAAE,KAAF,CAAQ,IAAR;AACH,KAFD;AAGH,CAJD;;AAOA;;;;;;;;;;;;;;;;;;;;;;;AAuBA,EAAE,cAAF,GAAmB,UAAS,UAAT,EAAiC;AAAA,QAAZ,OAAY,uEAAJ,EAAI;;AAChD,QAAI,iBAAiB,KAArB;;AAEA;;;;AAIA,WAAO,YAAW;AACd,YAAI,cAAJ,EAAoB;AAChB;AACH;;AAED,YAAM,UAAU,IAAhB;AACA,YAAM,OAAO,SAAb;;AAEA,yBAAiB,IAAjB;;AAEA,YAAI,KAAK,cAAM;AACX,uBAAW,KAAX,CAAiB,OAAjB,EAA0B,IAA1B;AACA,6BAAiB,KAAjB;AACH,SAHD;;AAKA,YAAI,QAAQ,KAAZ,EAAmB;AACf,iBAAK,EAAE,QAAF,CAAW,EAAX,CAAL;AACH;;AAED,8BAAsB,EAAtB;AACH,KApBD;AAqBH,CA5BD;;AA+BA;;;;;;;;;;;;AAYA,OAAO,MAAP,GAAgB,UAAS,GAAT,EAAc;AAC1B,WAAO,OAAO,cAAP,CAAsB,OAAO,cAAP,CAAsB,GAAtB,CAAtB,CAAP;AACH,CAFD","file":"underscoreUtils.js","sourcesContent":["/**\n * Bind callbacks to a context.\n *\n * Backbone.js's various ajax-related functions don't take a context\n * with their callbacks. This allows us to wrap these callbacks to ensure\n * we always have a desired context.\n *\n * Args:\n *     callbacks (object):\n *         An object which potentially includes callback functions.\n *\n *     context (any type):\n *         The context to bind to the callbacks.\n *\n *     methodNames (Array of string):\n *         An array of method names within ``callbacks`` to bind.\n *\n * Returns:\n *     object:\n *     A copy of the ``callbacks`` object, with the given ``methodNames`` bound\n *     to ``context``.\n */\n_.bindCallbacks = function(callbacks, context,\n                           methodNames=['success', 'error', 'complete']) {\n    if (!context) {\n        return callbacks;\n    }\n\n    const wrappedCallbacks = {};\n\n    for (let [key, value] of Object.entries(callbacks)) {\n        if (methodNames.includes(key) && _.isFunction(value)) {\n            wrappedCallbacks[key] = _.bind(value, context);\n        }\n    }\n\n    return _.defaults(wrappedCallbacks, callbacks);\n};\n\n\n/**\n * Return a function that will be called when the call stack has unwound.\n *\n * This will return a function that calls the provided function using\n * :js:func:`_.defer`.\n *\n * Args:\n *     func (function):\n *         The function to call.\n *\n * Returns:\n *     function:\n *     The wrapper function.\n */\n_.deferred = function(func) {\n    return () => {\n        _.defer(func);\n    };\n};\n\n\n/**\n * Return a function suitable for efficiently handling page layout.\n *\n * The returned function will use :js:func:`window.requestAnimationFrame` to\n * schedule the layout call. Once this function called, any subsequent calls\n * will be ignored until the first call has finished the layout work.\n *\n * Optionally, this can also defer layout work until the call stack has unwound.\n *\n * This is intended to be used as a resize event handler.\n *\n * Args:\n *     layoutFunc (function):\n *         The function to call to perform layout.\n *\n *     options (object):\n *         Options for the layout callback.\n *\n * Option Args:\n *     defer (boolean):\n *         If ``true``, the layout function will be called when the call stack\n *         has unwound after the next scheduled layout call.\n */\n_.throttleLayout = function(layoutFunc, options={}) {\n    let handlingLayout = false;\n\n    /*\n     * We don't want to use a fat arrow function here, since we need the\n     * caller's context to be preserved.\n     */\n    return function() {\n        if (handlingLayout) {\n            return;\n        }\n\n        const context = this;\n        const args = arguments;\n\n        handlingLayout = true;\n\n        let cb = () => {\n            layoutFunc.apply(context, args);\n            handlingLayout = false;\n        };\n\n        if (options.defer) {\n            cb = _.deferred(cb);\n        }\n\n        requestAnimationFrame(cb);\n    };\n};\n\n\n/*\n * Return the parent prototype for an object.\n *\n * Args:\n *     obj (object):\n *         An object.\n *\n * Returns:\n *     object:\n *     The object which is the parent prototype for the given ``obj``. This is\n *     roughly equivalent to what you'd get from ES6's ``super``.\n */\nwindow._super = function(obj) {\n    return Object.getPrototypeOf(Object.getPrototypeOf(obj));\n};\n"]}