{"version":3,"sources":["commentEditorModel.es6.js"],"names":[],"mappings":"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","file":"commentEditorModel.js","sourcesContent":["/**\n * Represents the state for editing a new or existing draft comment.\n *\n * From here, a comment can be created, edited, or deleted.\n *\n * This will provide state on what actions are available on a comment,\n * informative text, dirty states, existing published comments on the\n * same region this comment is on, and more.\n *\n * Attributes:\n *     canDelete (boolean):\n *         Whether the draft comment can be deleted.\n *\n *     canEdit (boolean):\n *         Whether the draft comment can be edited.\n *\n *     canSave (boolean):\n *         Whether the draft comment can be saved.\n *\n *     editing (boolean):\n *         True if the comment is currently being edited.\n *\n *     extraData (object):\n *         The draft state for the comment's extra data.\n *\n *     comment (RB.BaseComment):\n *         The comment model.\n *\n *     dirty (boolean):\n *         True if the draft comment has been edited but not saved.\n *\n *     openIssue (boolean):\n *         Whether the comment opens an issue.\n *\n *     publishedComments (Array of RB.BaseComment):\n *         The thread of previous comments that this draft is a reply to, if\n *         applicable.\n *\n *     publishedCommentsType (string):\n *         The type of comment that this draft is a reply to, if applicable.\n *\n *     reviewRequest (RB.ReviewRequest):\n *         The review request that the comment is on.\n *\n *     richText (boolean):\n *         Whether the comment is formatted in Markdown.\n *\n *     text (string):\n *         The comment's text.\n */\nRB.CommentEditor = Backbone.Model.extend(_.defaults({\n    /**\n     * Return the default values for the model attributes.\n     *\n     * Returns:\n     *     object:\n     *     The default values for the attributes.\n     */\n    defaults() {\n        const userSession = RB.UserSession.instance;\n\n        return {\n            canDelete: false,\n            canEdit: undefined,\n            canSave: false,\n            editing: false,\n            extraData: {},\n            comment: null,\n            dirty: false,\n            openIssue: userSession.get('commentsOpenAnIssue'),\n            publishedComments: [],\n            publishedCommentsType: null,\n            requireVerification: false, // TODO: add a user preference for this.\n            reviewRequest: null,\n            richText: userSession.get('defaultUseRichText'),\n            text: '',\n        };\n    },\n\n    /**\n     * Initialize the comment editor.\n     */\n    initialize() {\n        const reviewRequest = this.get('reviewRequest');\n\n        this.on('change:comment', this._updateFromComment, this);\n        this._updateFromComment();\n\n        /*\n         * Unless a canEdit value is explicitly given, we want to compute\n         * the proper state.\n         */\n        if (this.get('canEdit') === undefined) {\n            reviewRequest.on('change:hasDraft', this._updateCanEdit, this);\n            this._updateCanEdit();\n        }\n\n        this.on('change:dirty', (model, dirty) => {\n            const reviewRequestEditor = this.get('reviewRequestEditor');\n\n            if (reviewRequestEditor) {\n                if (dirty) {\n                    reviewRequestEditor.incr('editCount');\n                } else {\n                    reviewRequestEditor.decr('editCount');\n                }\n            }\n        });\n\n        this.on(\n            'change:openIssue change:requireVerification ' +\n            'change:richText change:text',\n            () => {\n                if (this.get('editing')) {\n                    this.set('dirty', true);\n                    this._updateState();\n                }\n            });\n\n        this._updateState();\n\n        this._setupExtraData();\n    },\n\n    /**\n     * Set the editor to begin editing a new or existing comment.\n     */\n    beginEdit() {\n        console.assert(this.get('canEdit'),\n                       'beginEdit() called when canEdit is false.');\n        console.assert(this.get('comment'),\n                       'beginEdit() called when no comment was first set.');\n\n        this.set({\n            dirty: false,\n            editing: true,\n        });\n\n        this._updateState();\n    },\n\n    /**\n     * Delete the current comment, if it can be deleted.\n     *\n     * This requires that there's a saved comment to delete.\n     *\n     * The editor will be marked as closed, requiring a new call to beginEdit.\n     */\n    deleteComment() {\n        console.assert(this.get('canDelete'),\n                       'deleteComment() called when canDelete is false.');\n\n        const comment = this.get('comment');\n        comment.destroy({\n            success: () => {\n                this.trigger('deleted');\n                this.close();\n            },\n        });\n    },\n\n    /**\n     * Cancel editing of a comment.\n     *\n     * If there's a saved comment and it's been made empty, it will end\n     * up being deleted. Then this editor will be marked as closed,\n     * requiring a new call to beginEdit.\n     */\n    cancel() {\n        const comment = this.get('comment');\n\n        this.off('change:comment', this._updateFromComment, this);\n\n        if (comment) {\n            comment.destroyIfEmpty();\n            this.trigger('canceled');\n        }\n\n        this.close();\n    },\n\n    /**\n     * Close editing of the comment.\n     *\n     * The comment state will be reset, and the \"closed\" event will be\n     * triggered.\n     *\n     * To edit a comment again after closing it, the proper state must be\n     * set again and beginEdit must be called.\n     */\n    close() {\n        /* Set this first, to prevent dirty firing. */\n        this.set('editing', false);\n\n        this.set({\n            comment: null,\n            dirty: false,\n            extraData: new RB.ExtraData(),\n            text: '',\n        });\n\n        this.trigger('closed');\n    },\n\n    /**\n     * Save the comment.\n     *\n     * If this is a new comment, it will be created on the server.\n     * Otherwise, the existing comment will be updated.\n     *\n     * The editor will not automatically be marked as closed. That is up\n     * to the caller.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options for the save operation.\n     *\n     *     context (object, optional):\n     *         The context to use when calling callbacks.\n     */\n    save(options={}, context=undefined) {\n        console.assert(this.get('canSave'),\n                       'save() called when canSave is false.');\n\n        const extraData =  _.clone(this.get('extraData'));\n        extraData.require_verification = this.get('requireVerification');\n\n        const comment = this.get('comment');\n        comment.set({\n            text: this.get('text'),\n            issueOpened: this.get('openIssue'),\n            extraData: extraData,\n            richText: this.get('richText'),\n            includeTextTypes: 'html,raw,markdown',\n        });\n\n        comment.save({\n            success: () => {\n                this.set('dirty', false);\n                this.trigger('saved');\n\n                if (_.isFunction(options.success)) {\n                    options.success.call(context);\n                }\n            },\n\n            error: _.isFunction(options.error)\n                   ? options.error.bind(context)\n                   : undefined,\n        });\n    },\n\n    /**\n     * Update the state of the editor from the currently set comment.\n     */\n    _updateFromComment() {\n        const oldComment = this.previous('comment');\n        const comment = this.get('comment');\n\n        if (oldComment) {\n            oldComment.destroyIfEmpty();\n        }\n\n        if (comment) {\n            const defaultRichText = this.defaults().richText;\n\n            /*\n             * Set the attributes based on what we know at page load time.\n             *\n             * Note that it is *possible* that the comments will have changed\n             * server-side since loading the page (if the user is reviewing\n             * the same diff in two tabs). However, it's unlikely.\n             *\n             * Doing this before the ready() call ensures that we'll have the\n             * text and state up-front and that it won't overwrite what the\n             * user has typed after load.\n             *\n             * Note also that we'll always want to use our default richText\n             * value if it's true, and we'll fall back on the comment's value\n             * if false. This is so that we can keep a consistent experience\n             * when the \"Always edit Markdown by default\" value is set.\n             */\n            this.set({\n                dirty: false,\n                extraData: comment.get('extraData'),\n                openIssue: comment.get('issueOpened') === null\n                           ? this.defaults().openIssue\n                           : comment.get('issueOpened'),\n                requireVerification: comment.requiresVerification(),\n                richText: defaultRichText || !!comment.get('richText'),\n            });\n\n            /*\n             * We'll try to set the one from the appropriate text fields, if it\n             * exists and is not empty. If we have this, then it came from a\n             * previous save. If we don't have it, we'll fall back to \"text\",\n             * which should be normalized content from the initial page load.\n             */\n            const textFields = (comment.get('richText') || !defaultRichText\n                                ? comment.get('rawTextFields')\n                                : comment.get('markdownTextFields'));\n\n            this.set('text',\n                     !_.isEmpty(textFields)\n                     ? textFields.text\n                     : comment.get('text'));\n\n            comment.ready({\n                ready: this._updateState,\n            }, this);\n        }\n    },\n\n    /**\n     * Update the canEdit state of the editor.\n     *\n     * This is based on the authentication state of the user, and\n     * whether or not there's an existing draft for the review request.\n     */\n    _updateCanEdit() {\n        const reviewRequest = this.get('reviewRequest');\n        const userSession = RB.UserSession.instance;\n\n        this.set('canEdit',\n                 userSession.get('authenticated') &&\n                 !reviewRequest.get('hasDraft'));\n    },\n\n    /**\n     * Update the capability states of the editor.\n     *\n     * Some of the can* properties will change to reflect the various\n     * actions that can be performed with the editor.\n     */\n    _updateState() {\n        const canEdit = this.get('canEdit');\n        const editing = this.get('editing');\n        const comment = this.get('comment');\n\n        this.set({\n            canDelete: canEdit && editing && comment && !comment.isNew(),\n            canSave: canEdit && editing && this.get('text') !== '',\n        });\n    },\n}, RB.ExtraDataMixin));\n"]}