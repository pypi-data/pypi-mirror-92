{"version":3,"sources":["centeredElementManager.es6.js"],"names":[],"mappings":";;AAAA;;;AAGA,GAAG,sBAAH,GAA4B,SAAS,IAAT,CAAc,MAAd,CAAqB;AAC7C;;;;;;;;;;;AAWA,cAZ6C,wBAYtB;AAAA;;AAAA,YAAZ,OAAY,uEAAJ,EAAI;;AACnB,aAAK,SAAL,GAAiB,QAAQ,QAAR,IAAoB,IAAI,GAAJ,EAArC;AACA,aAAK,QAAL,GAAgB,EAAE,MAAF,CAAhB;;AAEA,aAAK,wBAAL,GAAgC,EAAE,QAAF,CAAW;AAAA,mBAAM,MAAK,cAAL,EAAN;AAAA,SAAX,EACW,EADX,CAAhC;;AAGA,aAAK,QAAL,CAAc,EAAd,CAAiB,QAAjB,EAA2B,KAAK,wBAAhC;AACA,aAAK,QAAL,CAAc,EAAd,CAAiB,QAAjB,EAA2B,KAAK,wBAAhC;AACH,KArB4C;;;AAuB7C;;;;;AAKA,UA5B6C,oBA4BpC;AACL,iBAAS,IAAT,CAAc,SAAd,CAAwB,MAAxB,CAA+B,IAA/B,CAAoC,IAApC;;AAEA,aAAK,QAAL,CAAc,GAAd,CAAkB,QAAlB,EAA4B,KAAK,wBAAjC;AACA,aAAK,QAAL,CAAc,GAAd,CAAkB,QAAlB,EAA4B,KAAK,wBAAjC;AACH,KAjC4C;;;AAmC7C;;;;;;;AAOA,eA1C6C,uBA0CjC,QA1CiC,EA0CvB;AAClB,aAAK,SAAL,GAAiB,QAAjB;AACH,KA5C4C;;;AA8C7C;;;;;;AAMA,kBApD6C,4BAoD5B;AACb,YAAI,KAAK,SAAL,CAAe,IAAf,KAAwB,CAA5B,EAA+B;AAC3B;AACH;;AAED,YAAM,YAAY,KAAK,QAAL,CAAc,SAAd,EAAlB;AACA,YAAM,eAAe,KAAK,QAAL,CAAc,MAAd,EAArB;AACA,YAAM,eAAe,YAAY,YAAjC;;AAEA,aAAK,SAAL,CAAe,OAAf,CAAuB,UAAC,UAAD,EAAa,EAAb,EAAoB;AACvC,gBAAM,MAAM,EAAE,EAAF,CAAZ;AACA,gBAAM,gBAAgB,WAAW,IAAjC;AACA,gBAAM,mBAAmB,WAAW,OAAX,IAAsB,aAA/C;AACA,gBAAM,eAAe,cAAc,MAAd,GAAuB,GAA5C;AACA,gBAAM,kBAAkB,iBAAiB,MAAjB,GAA0B,GAA1B,GACA,iBAAiB,MAAjB,EADxB;;AAGA;;;;AAIA,gBAAI,eAAe,YAAf,IAA+B,kBAAkB,SAArD,EAAgE;AAC5D;;;;;AAKA,oBAAI,aAAa,YAAb,IACA,gBAAgB,eADpB,EACqC;AACjC,wBAAI,IAAI,GAAJ,CAAQ,UAAR,MAAwB,OAA5B,EAAqC;AACjC,4BAAI,GAAJ,CAAQ;AACJ,sCAAU,OADN;AAEJ,kCAAM,IAAI,MAAJ,GAAa,IAFf;AAGJ,iCAAK,KAAK,KAAL,CACD,CAAC,eAAe,IAAI,WAAJ,EAAhB,IAAqC,CADpC;AAHD,yBAAR;AAMH;AACJ,iBAVD,MAUO;AACH,wBAAM,MAAM,KAAK,GAAL,CAAS,SAAT,EAAoB,YAApB,CAAZ;AACA,wBAAM,SAAS,KAAK,GAAL,CAAS,YAAT,EAAuB,eAAvB,CAAf;AACA,wBAAM,QAAQ,MAAM,YAAN,GAAqB,KAAK,KAAL,CAC/B,CAAC,SAAS,GAAT,GAAe,IAAI,WAAJ,EAAhB,IAAqC,CADN,CAAnC;;AAGA,wBAAI,GAAJ,CAAQ;AACJ,kCAAU,UADN;AAEJ,8BAAM,EAFF;AAGJ,6BAAK;AAHD,qBAAR;AAKH;AACJ;AACJ,SAzCD;AA0CH;AAvG4C,CAArB,CAA5B","file":"centeredElementManager.js","sourcesContent":["/**\n * A view which ensures that the specified elements are vertically centered.\n */\nRB.CenteredElementManager = Backbone.View.extend({\n    /**\n     * Initialize the view.\n     *\n     * Args:\n     *     options (object):\n     *         Options passed to this view.\n     *\n     * Option Args:\n     *     elements (Array, optional):\n     *         An initial array of elements to center.\n     */\n    initialize(options={}) {\n        this._elements = options.elements || new Map();\n        this._$window = $(window);\n\n        this._updatePositionThrottled = _.throttle(() => this.updatePosition(),\n                                                   10);\n\n        this._$window.on('resize', this._updatePositionThrottled);\n        this._$window.on('scroll', this._updatePositionThrottled);\n    },\n\n    /**\n     * Remove the CenteredElementManager.\n     *\n     * This will result in the event handlers being removed.\n     */\n    remove() {\n        Backbone.View.prototype.remove.call(this);\n\n        this._$window.off('resize', this._updatePositionThrottled);\n        this._$window.off('scroll', this._updatePositionThrottled);\n    },\n\n    /**\n     * Set the elements and their containers.\n     *\n     * Args:\n     *     elements (Map<Element, Element or jQuery>):\n     *         The elements to center within their respective containers.\n     */\n    setElements(elements) {\n        this._elements = elements;\n    },\n\n    /**\n     * Update the position of the elements.\n     *\n     * This should only be done when the set of elements changed, as the view\n     * will handle updating on window resizing and scrolling.\n     */\n    updatePosition() {\n        if (this._elements.size === 0) {\n            return;\n        }\n\n        const windowTop = this._$window.scrollTop();\n        const windowHeight = this._$window.height();\n        const windowBottom = windowTop + windowHeight;\n\n        this._elements.forEach((containers, el) => {\n            const $el = $(el);\n            const $topContainer = containers.$top;\n            const $bottomContainer = containers.$bottom || $topContainer;\n            const containerTop = $topContainer.offset().top;\n            const containerBottom = $bottomContainer.offset().top +\n                                    $bottomContainer.height();\n\n            /*\n             * We don't have to vertically center the element when its\n             * container is not on screen.\n             */\n            if (containerTop < windowBottom && containerBottom > windowTop) {\n                /*\n                 * When a container takes up the entire viewport, we can switch\n                 * the CSS to use position: fixed. This way, we do not have to\n                 * re-compute its position.\n                 */\n                if (windowTop >= containerTop &&\n                    windowBottom <= containerBottom) {\n                    if ($el.css('position') !== 'fixed') {\n                        $el.css({\n                            position: 'fixed',\n                            left: $el.offset().left,\n                            top: Math.round(\n                                (windowHeight - $el.outerHeight()) / 2),\n                        });\n                    }\n                } else {\n                    const top = Math.max(windowTop, containerTop);\n                    const bottom = Math.min(windowBottom, containerBottom);\n                    const elTop = top - containerTop + Math.round(\n                        (bottom - top - $el.outerHeight()) / 2);\n\n                    $el.css({\n                        position: 'absolute',\n                        left: '',\n                        top: elTop,\n                    });\n                }\n            }\n        });\n    },\n});\n"]}