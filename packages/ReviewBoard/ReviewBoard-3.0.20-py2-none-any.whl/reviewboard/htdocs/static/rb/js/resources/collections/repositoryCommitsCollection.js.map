{"version":3,"sources":["repositoryCommitsCollection.es6.js"],"names":[],"mappings":";;AAAA;;;;;;;AAOA,GAAG,iBAAH,GAAuB,GAAG,cAAH,CAAkB,MAAlB,CAAyB;AAC5C,WAAO,GAAG,gBADkC;;AAG5C;;;;;;;;;;;;;;;;;;;;AAoBA,cAvB4C,sBAuBjC,MAvBiC,EAuBzB,OAvByB,EAuBhB;AACxB,iBAAS,UAAT,CAAoB,SAApB,CAA8B,UAA9B,CAAyC,IAAzC,CAA8C,IAA9C,EAAoD,MAApD,EAA4D,OAA5D;AACA,aAAK,OAAL,GAAe,OAAf;AACA,aAAK,IAAL,GAAY,KAAZ;AACA,aAAK,QAAL,GAAgB,KAAhB;AACH,KA5B2C;;;AA8B5C;;;;;;;;;;;AAWA,SAzC4C,iBAyCtC,QAzCsC,EAyC5B;AACZ,eAAO,SAAS,OAAhB;AACH,KA3C2C;;;AA6C5C;;;;;;;AAOA,OApD4C,iBAoDtC;AACF,YAAM,SAAS,EAAf;;AAEA,YAAI,KAAK,OAAL,CAAa,KAAb,KAAuB,SAA3B,EAAsC;AAClC,mBAAO,KAAP,GAAe,KAAK,OAAL,CAAa,KAA5B;AACH;;AAED,YAAI,KAAK,OAAL,CAAa,MAAb,KAAwB,SAA5B,EAAuC;AACnC,mBAAO,MAAP,GAAgB,KAAK,OAAL,CAAa,MAA7B;AACH;;AAED,eAAO,KAAK,OAAL,CAAa,OAAb,GAAuB,GAAvB,GAA6B,EAAE,KAAF,CAAQ,MAAR,CAApC;AACH,KAhE2C;;;AAkE5C;;;;;;;;AAQA,aA1E4C,uBA0EhC;AAAA;;AACR,YAAI,CAAC,KAAK,IAAN,IAAc,CAAC,KAAK,QAApB,IAAgC,KAAK,MAAL,CAAY,MAAhD,EAAwD;AACpD,gBAAI,YAAY,KAAK,MAAL,CAAY,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAAjC,EAAoC,GAApC,CAAwC,QAAxC,CAAhB;;AAEA,gBAAI,cAAc,EAAlB,EAAsB;AAClB,qBAAK,QAAL,GAAgB,IAAhB;AACH,aAFD,MAEO;AACH,qBAAK,OAAL,CAAa,KAAb,GAAqB,SAArB;;AAEA,qBAAK,KAAL,CAAW;AACP,4BAAQ,KADD;AAEP,6BAAS;AAAA,+BAAM,MAAK,IAAL,GAAY,KAAlB;AAAA;AAFF,iBAAX;AAIH;AACJ;AACJ;AAzF2C,CAAzB,CAAvB","file":"repositoryCommitsCollection.js","sourcesContent":["/**\n * A collection of commits in a repository.\n *\n * This is expected to be used in an ephemeral manner to get a list of commits\n * from a given start point (usually corresponding to some branch in the\n * repository).\n */\nRB.RepositoryCommits = RB.BaseCollection.extend({\n    model: RB.RepositoryCommit,\n\n    /**\n     * Initialize the collection.\n     *\n     * Args:\n     *     models (Array of object):\n     *         Initial models for the collection.\n     *\n     *     options (Object):\n     *         Options for the collection.\n     *\n     * Option Args:\n     *     start (string):\n     *         The start commit for fetching commit logs.\n     *\n     *     branch (string):\n     *         The branch name for fetching commit logs.\n     *\n     *     urlBase (string):\n     *         The base URL for the API request.\n     */\n    initialize(models, options) {\n        Backbone.Collection.prototype.initialize.call(this, models, options);\n        this.options = options;\n        this.busy = false;\n        this.complete = false;\n    },\n\n    /**\n     * Parse the response.\n     *\n     * Args:\n     *     response (object):\n     *         Response, parsed from the JSON returned by the server.\n     *\n     * Returns:\n     *     Array of object:\n     *     An array of commits.\n     */\n    parse(response) {\n        return response.commits;\n    },\n\n    /**\n     * Get the URL to fetch for the next page of results.\n     *\n     * Returns:\n     *     string:\n     *     The URL to fetch.\n     */\n    url() {\n        const params = {};\n\n        if (this.options.start !== undefined) {\n            params.start = this.options.start;\n        }\n\n        if (this.options.branch !== undefined) {\n            params.branch = this.options.branch;\n        }\n\n        return this.options.urlBase + '?' + $.param(params);\n    },\n\n    /**\n     * Fetch the next page of results.\n     *\n     * This can be called multiple times. If this is called when a fetch is\n     * already in progress, it's a no-op. Otherwise, if there are more commits\n     * to load, it will fetch them and add them to the bottom of the\n     * collection.\n     */\n    fetchNext() {\n        if (!this.busy && !this.complete && this.models.length) {\n            let nextStart = this.models[this.models.length - 1].get('parent');\n\n            if (nextStart === '') {\n                this.complete = true;\n            } else {\n                this.options.start = nextStart;\n\n                this.fetch({\n                    remove: false,\n                    success: () => this.busy = false\n                });\n            }\n        }\n    }\n});\n"]}