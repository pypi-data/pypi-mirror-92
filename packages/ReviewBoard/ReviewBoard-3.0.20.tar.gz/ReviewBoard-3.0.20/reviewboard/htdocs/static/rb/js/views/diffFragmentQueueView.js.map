{"version":3,"sources":["diffFragmentQueueView.es6.js"],"names":[],"mappings":";;AAAA;;;;;;AAMA,GAAG,qBAAH,GAA2B,SAAS,IAAT,CAAc,MAAd,CAAqB;AAC5C;;;;;;;;;;;;;;;;;;;;;;;AAuBA,cAxB4C,sBAwBjC,OAxBiC,EAwBxB;AAChB,aAAK,gBAAL,GAAwB,QAAQ,eAAhC;AACA,aAAK,wBAAL,GAAgC,QAAQ,uBAAxC;AACA,aAAK,kBAAL,GACO,QAAQ,iBADf;AAEA,aAAK,UAAL,GAAkB,QAAQ,SAA1B;;AAEA,aAAK,MAAL,GAAc,EAAd;AACA,aAAK,MAAL,GAAc,EAAd;AACH,KAjC2C;;;AAmC5C;;;;;;;;;;;;;;;;;;AAkBA,aArD4C,qBAqDlC,SArDkC,EAqDvB,GArDuB,EAqDlB,kBArDkB,EAqDE;AAC1C,YAAM,QAAQ,KAAK,MAAnB;;AAEA,YAAI,CAAC,MAAM,GAAN,CAAL,EAAiB;AACb,kBAAM,GAAN,IAAa,EAAb;AACH;;AAED,cAAM,GAAN,EAAW,IAAX,CAAgB;AACZ,uBAAW,SADC;AAEZ,gCAAoB,sBAAsB;AAF9B,SAAhB;AAIH,KAhE2C;;;AAkE5C;;;;;;;;;;;;AAYA,gBA9E4C,wBA8E/B,SA9E+B,EA8EpB;AACpB,YAAM,MAAM,KAAK,oBAAL,CAA0B,SAA1B,CAAZ;;AAEA,YAAI,IAAI,MAAJ,KAAe,CAAf,IAAoB,IAAI,IAAJ,CAAS,oBAAT,CAAxB,EAAwD;AACpD,iBAAK,MAAL,CAAY,SAAZ,IAAyB,IAAI,IAAJ,EAAzB;AACH;AACJ,KApF2C;;;AAsF5C;;;;;;;;;;;;;AAaA,iBAnG4C,yBAmG9B,MAnG8B,EAmGtB;AAAA;;AAClB,YAAI,EAAE,OAAF,CAAU,KAAK,MAAf,KAA0B,EAAE,OAAF,CAAU,KAAK,MAAf,CAA9B,EAAsD;AAClD,gBAAI,EAAE,UAAF,CAAa,MAAb,CAAJ,EAA0B;AACtB;AACH;;AAED;AACH;;AAED,YAAM,YAAY,KAAK,UAAvB;;AAEA,UAAE,IAAF,CAAO,KAAK,MAAZ,EAAoB,uBAAe;AAC/B,cAAE,SAAF,CAAY,SAAZ,EAAuB,GAAvB,CAA2B,YAAM;AAC7B,oBAAM,oBAAoB,EAA1B;AACA,oBAAM,0BAA0B,EAAhC;;AAEA;;;;AAIA,qBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,YAAY,MAAhC,EAAwC,GAAxC,EAA6C;AACzC,wBAAM,aAAa,YAAY,CAAZ,CAAnB;AACA,wBAAM,YAAY,WAAW,SAA7B;AACA,wBAAM,qBACF,EAAE,UAAF,CAAa,WAAW,kBAAxB,IACE,WAAW,kBADb,GAEE,IAHN;;AAKA,wBAAI,MAAK,MAAL,CAAY,cAAZ,CAA2B,SAA3B,CAAJ,EAA2C;AACvC,4BAAM,OAAO,MAAK,MAAL,CAAY,SAAZ,CAAb;;AAEA,4BAAM,YAAY,MAAK,oBAAL,CAA0B,SAA1B,CAAlB;AACA,gCAAQ,MAAR,CAAe,SAAf;;AAEA,4BAAI,OAAO,UAAU,IAAV,CAAe,oBAAf,CAAX;;AAEA,4BAAI,IAAJ,EAAU;AACN,iCAAK,GAAL,CAAS,IAAT,CAAc,IAAd;AACA,iCAAK,MAAL;AACH,yBAHD,MAGO;AACH,mCAAO,MAAK,eAAL,CAAqB,SAArB,EAAgC,SAAhC,EACqB,IADrB,CAAP;AAEH;;AAED,4BAAI,kBAAJ,EAAwB;AACpB,+CAAmB,IAAnB;AACH;;AAED,+BAAO,MAAK,MAAL,CAAY,SAAZ,CAAP;AACH,qBArBD,MAqBO;AACH,0CAAkB,IAAlB,CAAuB,SAAvB;AACA,gDAAwB,SAAxB,IACI,kBADJ;AAEH;AACJ;;AAED,oBAAI,kBAAkB,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B;;;;;;;AAOA,0BAAK,SAAL,CAAe,kBAAkB,IAAlB,CAAuB,GAAvB,CAAf,EAA4C;AACxC,mCAAW,SAD6B;AAExC,4CAAoB,4BAAC,SAAD,EAAY,IAAZ,EAAqB;AACrC,gCAAI,wBAAwB,SAAxB,CAAJ,EAAwC;AACpC,wDAAwB,SAAxB,EAAmC,IAAnC;AACH;AACJ,yBANuC;AAOxC,gCAAQ;AAAA,mCAAM,EAAE,SAAF,CAAY,SAAZ,EAAuB,IAAvB,EAAN;AAAA;AAPgC,qBAA5C;AASH,iBAjBD,MAiBO;AACH;;;;AAIA,sBAAE,SAAF,CAAY,SAAZ,EAAuB,IAAvB;AACH;AACJ,aApED;AAqEH,SAtED;;AAwEA,YAAI,EAAE,UAAF,CAAa,MAAb,CAAJ,EAA0B;AACtB,cAAE,SAAF,CAAY,SAAZ,EAAuB,GAAvB,CAA2B,YAAM;AAC7B;AACA,kBAAE,SAAF,CAAY,SAAZ,EAAuB,IAAvB;AACH,aAHD;AAIH;;AAED;AACA,aAAK,MAAL,GAAc,EAAd;;AAEA,UAAE,SAAF,CAAY,SAAZ,EAAuB,KAAvB;AACH,KAjM2C;;;AAmM5C;;;;;;;;;;;;AAYA,wBA/M4C,gCA+MvB,SA/MuB,EA+MZ;AAC5B,eAAO,QAAM,KAAK,gBAAX,SAA+B,SAA/B,CAAP;AACH,KAjN2C;;;AAmN5C;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,aA7O4C,qBA6OlC,UA7OkC,EA6OV;AAAA;;AAAA,YAAZ,OAAY,uEAAJ,EAAI;;AAC9B,YAAM,kBAAkB,KAAK,gBAA7B;AACA,YAAM,YAAY,EAAlB;AACA,YAAM,qBAAsB,EAAE,UAAF,CAAa,QAAQ,kBAArB,IACE,QAAQ,kBADV,GAEE,IAF9B;;AAIA,YAAI,QAAQ,cAAR,KAA2B,SAA/B,EAA0C;AACtC,sBAAU,IAAV,uBAAmC,QAAQ,cAA3C;AACH;;AAED,YAAI,CAAC,gBAAgB,QAAhB,CAAyB,OAAzB,CAAL,EAAwC;AACpC,sBAAU,IAAV,CAAe,mBAAf;AACH;;AAED,kBAAU,IAAV,CAAe,eAAf;;AAEA,WAAG,OAAH,CAAW;AACP,sBAAQ,KAAK,kBAAb,GAAkC,UAAlC,MADO;AAEP,kBAAM,UAAU,IAAV,CAAe,GAAf,CAFC;AAGP,sBAAU,aAHH;AAIP,kBAAM,KAJC;AAKP,qBAAS,8BAAe;AACpB,oBAAM,WAAW,IAAI,QAAJ,CAAa,WAAb,CAAjB;AACA,oBAAM,MAAM,SAAS,UAArB;AACA,oBAAI,MAAM,CAAV;AACA,oBAAI,iBAAiB,CAArB;AACA,oBAAI,eAAe,CAAnB;AACA,oBAAI,OAAO,KAAX;;AAEA,oBAAM,mBAAmB,SAAnB,gBAAmB,CAAC,SAAD,EAAY,IAAZ,EAAqB;AAC1C;AACA,wBAAM,oBAAkB,eAAlB,SAAqC,SAA3C;AACA,wBAAM,aAAa,EAAE,WAAF,CAAnB;;AAEA,wBAAI,WAAW,MAAX,KAAsB,CAA1B,EAA6B;AACzB;;;;;;AAMA,gCAAQ,KAAR,CAAc,qCACA,sCADA,GAEA,wBAFd,EAGc,WAHd,EAG2B,SAH3B;AAIH,qBAXD,MAWO;AACH,4BAAM,OAAO,OAAK,eAAL,CACT,QAAM,eAAN,SAAyB,SAAzB,CADS,EAET,SAFS,EAGT,IAHS,CAAb;;AAKA,4BAAI,kBAAJ,EAAwB;AACpB,+CAAmB,SAAnB,EAA8B,IAA9B;AACH;AACJ;;AAED;;AAEA,wBAAI,QAAQ,iBAAiB,cAAzB,IACA,EAAE,UAAF,CAAa,QAAQ,MAArB,CADJ,EACkC;AAC9B;;;;AAIA,gCAAQ,MAAR;AACH;AACJ,iBArCD;;AAuCA,uBAAO,CAAC,IAAR,EAAc;AACV,wBAAM,SAAS,OAAK,6BAAL,CACX,WADW,EACE,QADF,EACY,GADZ,CAAf;;AAGA;AACA,0BAAM,OAAO,GAAb;AACA,2BAAQ,OAAO,GAAf;;AAEA,2BAAO,IAAP,CAAY,gBAAZ;AACH;AACJ;AA9DM,SAAX;AAgEH,KA9T2C;;;AAgU5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,iCA9V4C,yCA8Vd,WA9Vc,EA8VD,QA9VC,EA8VS,GA9VT,EA8Vc;AACtD;AACA,YAAM,YAAY,SAAS,SAAT,CAAmB,GAAnB,EAAwB,IAAxB,CAAlB;AACA,eAAO,CAAP;;AAEA;AACA,YAAM,UAAU,SAAS,SAAT,CAAmB,GAAnB,EAAwB,IAAxB,CAAhB;AACA,eAAO,CAAP;;AAEA;AACA,YAAM,YAAY,GAAlB;AACA,eAAO,OAAP;;AAEA,eAAO;AACH,iBAAK,GADF;AAEH,gBAFG,gBAEE,EAFF,EAEM;AACL,mBAAG,SAAH,CAAa,gBAAb,CACI,IAAI,IAAJ,CAAS,CAAC,YAAY,KAAZ,CAAkB,SAAlB,EACkB,YAAY,OAD9B,CAAD,CAAT,CADJ,EAGI;AAAA,2BAAQ,GAAG,SAAH,EAAc,IAAd,CAAR;AAAA,iBAHJ;AAIH;AAPE,SAAP;AASH,KApX2C;;;AAsX5C;;;;;;;;;;;;;;;;;;;;AAoBA,mBA1Y4C,2BA0Y5B,UA1Y4B,EA0YhB,SA1YgB,EA0YL,IA1YK,EA0YC;AAAA;;AACzC,WAAG,aAAH,CAAiB,aAAjB,CAA+B,UAA/B;;AAEA,mBAAW,IAAX,CAAgB,IAAhB;;AAEA,YAAI,OAAO,WAAW,IAAX,CAAgB,oBAAhB,CAAX;;AAEA,YAAI,CAAC,IAAL,EAAW;AACP,mBAAO,IAAI,GAAG,gBAAP,CAAwB,EAAE,QAAF,CAAW;AACtC,oBAAI,UADkC;AAEtC,0BAAU,2BAAW;AACjB,uBAAG,oBAAH,CAAwB,IAAxB,EAA8B,EAAC,MAAM,KAAP,EAA9B;;AAEA,2BAAK,SAAL,CAAe,SAAf,EAA0B,EAAE,QAAF,CAAW;AACjC,8BADiC,oBACxB;AACL,+BAAG,oBAAH,CAAwB,KAAxB,EAA+B,EAA/B;;AAEA,gCAAI,QAAQ,MAAZ,EAAoB;AAChB,wCAAQ,MAAR;AACH;AACJ;AAPgC,qBAAX,EAQvB,OARuB,CAA1B;AASH;AAdqC,aAAX,EAe5B,KAAK,wBAfuB,CAAxB,CAAP;AAgBA,uBAAW,IAAX,CAAgB,oBAAhB,EAAsC,IAAtC;AACH;;AAED,aAAK,MAAL;;AAEA,WAAG,aAAH,CAAiB,WAAjB,CAA6B,UAA7B;;AAEA,eAAO,IAAP;AACH;AA1a2C,CAArB,CAA3B","file":"diffFragmentQueueView.js","sourcesContent":["/**\n * Queues loading of diff fragments from a page.\n *\n * This is used to load diff fragments one-by-one, and to intelligently\n * batch the loads to only fetch at most one set of fragments per file.\n */\nRB.DiffFragmentQueueView = Backbone.View.extend({\n    /**\n     * Initialize the queue.\n     *\n     * Args:\n     *     options (object):\n     *         Options passed to this view.\n     *\n     * Returns:\n     *     containerPrefix (string):\n     *         The prefix to prepend to diff comment IDs when forming\n     *         container element IDs.\n     *\n     *     diffFragmentViewOptions (object, optional):\n     *         Options to pass to each :js:class:`RB.DiffFragmentView` that's\n     *         created.\n     *\n     *     reviewRequestPath (string):\n     *         The URL for the review request that diff fragments will be\n     *         loaded from.\n     *\n     *     queueName (string):\n     *         The name of the diff loading queue.\n     */\n    initialize(options) {\n        this._containerPrefix = options.containerPrefix;\n        this._diffFragmentViewOptions = options.diffFragmentViewOptions;\n        this._fragmentsBasePath =\n            `${options.reviewRequestPath}_fragments/diff-comments/`;\n        this._queueName = options.queueName;\n\n        this._queue = {};\n        this._saved = {};\n    },\n\n    /**\n     * Queue the load of a diff fragment from the server.\n     *\n     * This will be added to a list, which will fetch the comments in batches\n     * based on file IDs.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to queue.\n     *\n     *     key (string):\n     *         The key for the queue. Each comment with the same key will be\n     *         loaded in a batch. This will generally be the ID of a file.\n     *\n     *     onFragmentRendered (function, optional):\n     *         Optional callback for when the view for the fragment has\n     *         rendered. Contains the view as a parameter.\n     */\n    queueLoad(commentID, key, onFragmentRendered) {\n        const queue = this._queue;\n\n        if (!queue[key]) {\n            queue[key] = [];\n        }\n\n        queue[key].push({\n            commentID: commentID,\n            onFragmentRendered: onFragmentRendered || null,\n        });\n    },\n\n    /**\n     * Save a comment's loaded diff fragment for the next load operation.\n     *\n     * If the comment's diff fragment was already loaded, it will be\n     * temporarily stored until the next load operation involving that\n     * comment. Instead of loading the fragment from the server, the saved\n     * fragment's HTML will be used instead.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment to save.\n     */\n    saveFragment(commentID) {\n        const $el = this._getCommentContainer(commentID);\n\n        if ($el.length === 1 && $el.data('diff-fragment-view')) {\n            this._saved[commentID] = $el.html();\n        }\n    },\n\n    /**\n     * Load all queued diff fragments.\n     *\n     * The diff fragments for each keyed set in the queue will be loaded as\n     * a batch. The resulting fragments will be injected into the DOM.\n     *\n     * Any existing fragments that were saved will be loaded from the cache\n     * without requesting them from the server.\n     *\n     * Args:\n     *     onDone (function, optional):\n     *         Callback for when all fragments have been loaded.\n     */\n    loadFragments(onDone) {\n        if (_.isEmpty(this._queue) && _.isEmpty(this._saved)) {\n            if (_.isFunction(onDone)) {\n                onDone();\n            }\n\n            return;\n        }\n\n        const queueName = this._queueName;\n\n        _.each(this._queue, queuedLoads => {\n            $.funcQueue(queueName).add(() => {\n                const pendingCommentIDs = [];\n                const onFragmentRenderedFuncs = {};\n\n                /*\n                 * Check if there are any comment IDs that have been saved.\n                 * We don't need to reload these from the server.\n                 */\n                for (let i = 0; i < queuedLoads.length; i++) {\n                    const queuedLoad = queuedLoads[i];\n                    const commentID = queuedLoad.commentID;\n                    const onFragmentRendered =\n                        _.isFunction(queuedLoad.onFragmentRendered)\n                        ? queuedLoad.onFragmentRendered\n                        : null;\n\n                    if (this._saved.hasOwnProperty(commentID)) {\n                        const html = this._saved[commentID];\n\n                        const container = this._getCommentContainer(commentID);\n                        console.assert(container);\n\n                        let view = container.data('diff-fragment-view');\n\n                        if (view) {\n                            view.$el.html(html);\n                            view.render();\n                        } else {\n                            view = this._renderFragment(container, commentID,\n                                                        html);\n                        }\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(view);\n                        }\n\n                        delete this._saved[commentID];\n                    } else {\n                        pendingCommentIDs.push(commentID);\n                        onFragmentRenderedFuncs[commentID] =\n                            onFragmentRendered;\n                    }\n                }\n\n                if (pendingCommentIDs.length > 0) {\n                    /*\n                     * There are some comment IDs we don't have. Load these\n                     * from the server.\n                     *\n                     * Once these are loaded, they'll call next() on the queue\n                     * to process the next batch.\n                     */\n                    this._loadDiff(pendingCommentIDs.join(','), {\n                        queueName: queueName,\n                        onFragmentRendered: (commentID, view) => {\n                            if (onFragmentRenderedFuncs[commentID]) {\n                                onFragmentRenderedFuncs[commentID](view);\n                            }\n                        },\n                        onDone: () => $.funcQueue(queueName).next(),\n                    });\n                } else {\n                    /*\n                     * We processed all we need to process above. Go to the\n                     * next queue.\n                     */\n                    $.funcQueue(queueName).next();\n                }\n            });\n        });\n\n        if (_.isFunction(onDone)) {\n            $.funcQueue(queueName).add(() => {\n                onDone();\n                $.funcQueue(queueName).next();\n            });\n        }\n\n        // Clear the list.\n        this._queue = {};\n\n        $.funcQueue(queueName).start();\n    },\n\n    /**\n     * Return the container for a particular comment.\n     *\n     * Args:\n     *     commentID (string):\n     *         The ID of the comment.\n     *\n     * Returns:\n     *     jQuery:\n     *     The comment container, wrapped in a jQuery element. The caller\n     *     may want to check the length to be sure the container was found.\n     */\n    _getCommentContainer(commentID) {\n        return $(`#${this._containerPrefix}_${commentID}`);\n    },\n\n    /**\n     * Load a diff fragment for the given comment IDs and options.\n     *\n     * This will construct the URL for the relevant diff fragment and load\n     * it from the server.\n     *\n     * Args:\n     *     commentIDs (string):\n     *         A string of comment IDs to load fragments for.\n     *\n     *     options (object, optional):\n     *         Options for the loaded diff fragments.\n     *\n     * Option Args:\n     *     linesOfContext (string):\n     *         The lines of context to load for the diff. This is a string\n     *         containing a comma-separated set of line counts in the form\n     *         of ``numLinesBefore,numLinesAfter``.\n     *\n     *     onDone (function):\n     *         A function to call after the diff has been loaded.\n     *\n     *     queueName (string):\n     *         The name of the load queue. This is used to load batches of\n     *         fragments sequentially.\n     */\n    _loadDiff(commentIDs, options={}) {\n        const containerPrefix = this._containerPrefix;\n        const queryArgs = [];\n        const onFragmentRendered = (_.isFunction(options.onFragmentRendered)\n                                    ? options.onFragmentRendered\n                                    : null);\n\n        if (options.linesOfContext !== undefined) {\n            queryArgs.push(`lines_of_context=${options.linesOfContext}`);\n        }\n\n        if (!containerPrefix.includes('draft')) {\n            queryArgs.push('allow_expansion=1');\n        }\n\n        queryArgs.push(TEMPLATE_SERIAL);\n\n        RB.apiCall({\n            url: `${this._fragmentsBasePath}${commentIDs}/`,\n            data: queryArgs.join('&'),\n            dataType: 'arraybuffer',\n            type: 'GET',\n            success: arrayBuffer => {\n                const dataView = new DataView(arrayBuffer);\n                const len = dataView.byteLength;\n                let pos = 0;\n                let totalFragments = 0;\n                let totalRenders = 0;\n                let done = false;\n\n                const onFragmentLoaded = (commentID, html) => {\n                    /* Set the HTML in the container. */\n                    const containerID = `#${containerPrefix}_${commentID}`;\n                    const $container = $(containerID);\n\n                    if ($container.length === 0) {\n                        /*\n                         * This doesn't actually exist. We may be dealing with\n                         * inconsistent state due to something missing in the\n                         * database. We don't want to break the page if this\n                         * happens, so log and skip the entry.\n                         */\n                        console.error('Unable to find container %s for ' +\n                                      'comment ID %s. There may be missing ' +\n                                      'state in the database.',\n                                      containerID, commentID);\n                    } else {\n                        const view = this._renderFragment(\n                            $(`#${containerPrefix}_${commentID}`),\n                            commentID,\n                            html);\n\n                        if (onFragmentRendered) {\n                            onFragmentRendered(commentID, view);\n                        }\n                    }\n\n                    totalRenders++;\n\n                    if (done && totalRenders === totalFragments &&\n                        _.isFunction(options.onDone)) {\n                        /*\n                         * We've parsed and rendered all fragments, so we're\n                         * officially done.\n                         */\n                        options.onDone();\n                    }\n                }\n\n                while (!done) {\n                    const parsed = this._parseDiffFragmentFromPayload(\n                        arrayBuffer, dataView, pos);\n\n                    totalFragments++;\n                    pos = parsed.pos;\n                    done = (pos >= len);\n\n                    parsed.load(onFragmentLoaded);\n                }\n            }\n        });\n    },\n\n    /**\n     * Parse a single diff fragment from the payload.\n     *\n     * This will parse out information about the fragment (the comment ID and\n     * HTML) and return a response containing the new position and a function\n     * to call in order to load the parsed fragment.\n     *\n     * Args:\n     *     arrayBuffer (ArrayBuffer):\n     *         The array buffer being parsed.\n     *\n     *     dataView (DataView):\n     *         The data view on top of the array buffer, used to extract\n     *         information.\n     *\n     *     pos (number):\n     *         The current position within the array buffer.\n     *\n     * Returns:\n     *     object:\n     *     An object with two keys:\n     *\n     *     ``pos``:\n     *         The next position to parse.\n     *\n     *     ``load``:\n     *         A function for loading the fragment content. This takes a\n     *         callback function as an argument containing ``commentID`` and\n     *         ``html`` arguments.\n     */\n    _parseDiffFragmentFromPayload(arrayBuffer, dataView, pos) {\n        /* Read the comment ID. */\n        const commentID = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the length of the HTML. */\n        const htmlLen = dataView.getUint32(pos, true);\n        pos += 4;\n\n        /* Read the HTML position for later. */\n        const htmlStart = pos;\n        pos += htmlLen;\n\n        return {\n            pos: pos,\n            load(cb) {\n                RB.DataUtils.readBlobAsString(\n                    new Blob([arrayBuffer.slice(htmlStart,\n                                                htmlStart + htmlLen)]),\n                    html => cb(commentID, html));\n            },\n        };\n    },\n\n    /**\n     * Render a diff fragment on the page.\n     *\n     * This will set up a view for the diff fragment, if one is not already\n     * created, and render it on the page.\n     *\n     * It will also mark the fragment for updates with the scroll manager\n     * so that if the user is scrolled to a location past the fragment, the\n     * resulting size change for the fragment won't cause the page to jump.\n     *\n     * Args:\n     *     $container (jQuery):\n     *         The container element where the fragment will be injected.\n     *\n     *     commentID (number):\n     *         The ID of the comment.\n     *\n     *     html (string):\n     *         The HTML contents of the fragment.\n     */\n    _renderFragment($container, commentID, html) {\n        RB.scrollManager.markForUpdate($container);\n\n        $container.html(html);\n\n        let view = $container.data('diff-fragment-view');\n\n        if (!view) {\n            view = new RB.DiffFragmentView(_.defaults({\n                el: $container,\n                loadDiff: options => {\n                    RB.setActivityIndicator(true, {type: 'GET'});\n\n                    this._loadDiff(commentID, _.defaults({\n                        onDone() {\n                            RB.setActivityIndicator(false, {});\n\n                            if (options.onDone) {\n                                options.onDone();\n                            }\n                        },\n                    }, options));\n                },\n            }, this._diffFragmentViewOptions));\n            $container.data('diff-fragment-view', view);\n        }\n\n        view.render();\n\n        RB.scrollManager.markUpdated($container);\n\n        return view;\n    },\n});\n"]}