{"version":3,"sources":["resourceCollection.es6.js"],"names":[],"mappings":"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","file":"resourceCollection.js","sourcesContent":["/**\n * Base collection for resource models.\n *\n * ResourceCollection handles the fetching of models from resource lists\n * in the API.\n *\n * It can do pagination by using fetchNext/fetchPrev. Callers can check\n * hasNext/hasPrev to determine if they've reached the end.\n *\n * To fetch one page at a time, use fetch(). This can take an optional\n * starting point.\n *\n * Use fetchAll to automatically paginate through all items and store them\n * all within the collection.\n */\nRB.ResourceCollection = RB.BaseCollection.extend({\n    /**\n     * Initialize the collection.\n     *\n     * Args:\n     *     models (Array of object):\n     *         Initial set of models for the collection.\n     *\n     *     options (object):\n     *         Options for the collection.\n     *\n     * Option Args:\n     *     parentResource (RB.BaseResource):\n     *         The parent API resource.\n     *\n     *     extraQueryData (object):\n     *         Additional attributes to include in the API request query\n     *         string.\n     */\n    initialize(models, options) {\n        this.parentResource = options.parentResource;\n        this.extraQueryData = options.extraQueryData;\n        this.maxResults = options.maxResults;\n        this.hasPrev = false;\n        this.hasNext = false;\n        this.currentPage = 0;\n\n        /*\n         * Undefined means \"we don't know how many results there are.\"\n         * This is a valid value when parsing the payload later. It\n         * may also be a number.\n         */\n        this.totalResults = undefined;\n\n        this._fetchURL = null;\n        this._links = null;\n    },\n\n    /**\n     * Return the URL for fetching models.\n     *\n     * This will make use of a URL provided by fetchNext/fetchPrev/fetchAll,\n     * if provided.\n     *\n     * Otherwise, this will try to get the URL from the parent resource.\n     *\n     * Returns:\n     *     string:\n     *     The URL to fetch.\n     */\n    url() {\n        if (this._fetchURL) {\n            return this._fetchURL;\n        }\n\n        if (this.parentResource) {\n            const links = this.parentResource.get('links');\n            const listKey = _.result(this.model.prototype, 'listKey');\n            const link = links[listKey];\n\n            return link ? link.href : null;\n        }\n\n        return null;\n    },\n\n    /**\n     * Parse the results from the list payload.\n     *\n     * Args:\n     *     rsp (object):\n     *         The response from the server.\n     *\n     *     options (object):\n     *         The options that were used for the fetch operation.\n     *\n     * Option Args:\n     *     fetchingAll (boolean):\n     *         Whether we're in the process of fetching all the items.\n     *\n     *     page (number):\n     *         The page of results that were fetched.\n     */\n    parse(rsp, options={}) {\n        const listKey = _.result(this.model.prototype, 'listKey');\n\n        this._links = rsp.links || null;\n        this.totalResults = rsp.total_results;\n\n        if (options.fetchingAll) {\n            this.hasPrev = false;\n            this.hasNext = false;\n            this.currentPage = 0;\n        } else {\n            this.totalResults = rsp.total_results;\n            this.hasPrev = (this._links !== null &&\n                            this._links.prev !== undefined);\n            this.hasNext = (this._links !== null &&\n                            this._links.next !== undefined);\n            this.currentPage = options.page;\n        }\n\n        return rsp[listKey];\n    },\n\n    /**\n     * Fetch models from the list.\n     *\n     * By default, this will replace the list of models in this collection.\n     * That can be changed by providing `reset: false` in options.\n     *\n     * The first page of resources will be fetched unless options.start is\n     * set. The value is the start position for the number of objects, not\n     * pages.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the fetch operation.\n     *\n     *     context (object):\n     *         Context to bind when calling callbacks.\n     *\n     * Option Args:\n     *     start (string):\n     *         The start position to use when fetching paginated results.\n     *\n     *     maxResults (number):\n     *         The number of results to return.\n     *\n     *     reset (boolean):\n     *         Whether the collection should be reset with the newly-fetched\n     *         items, or those items should be appended to the collection.\n     *\n     *     data (object):\n     *         Data to pass to the API request.\n     *\n     *     success (function):\n     *         Callback to be called when the fetch is successful.\n     *\n     *     error (function):\n     *         Callback to be called when the fetch fails.\n     *\n     *     complete (function):\n     *         Callback to be called after either success or error.\n     *\n     * Returns:\n     *     boolean:\n     *     Whether the fetch was successfully initiated.\n     */\n    fetch(options={}, context=undefined) {\n        const data = _.extend({}, options.data);\n\n        if (options.start !== undefined) {\n            data.start = options.start;\n        }\n\n        /*\n         * There's a couple different ways that the max number of results\n         * can be specified. We'll want to support them all.\n         *\n         * If a value is passed in extraQueryData, it takes precedence.\n         * We'll just set it further down. Otherwise, options.maxResults\n         * will be used if passed, falling back on the maxResults passed\n         * during collection construction.\n         */\n        if (!this.extraQueryData ||\n            this.extraQueryData['max-results'] === undefined) {\n            if (options.maxResults !== undefined) {\n                data['max-results'] = options.maxResults;\n            } else if (this.maxResults) {\n                data['max-results'] = this.maxResults;\n            }\n        }\n\n        if (options.reset === undefined) {\n            options.reset = true;\n        }\n\n        /*\n         * Versions of Backbone prior to 1.1 won't respect the reset option,\n         * instead requiring we use 'remove'. Support this for compatibility,\n         * until we move to Backbone 1.1.\n         */\n        options.remove = options.reset;\n\n        const expandedFields = this.model.prototype.expandedFields;\n        if (expandedFields.length > 0) {\n            data.expand = expandedFields.join(',');\n        }\n\n        if (this.extraQueryData) {\n            _.defaults(data, this.extraQueryData);\n        }\n\n        options.data = data;\n\n        if (this.parentResource) {\n            this.parentResource.ready({\n                ready: () => RB.BaseCollection.prototype.fetch.call(\n                    this, options, context),\n                error: _.isFunction(options.error)\n                       ? options.error.bind(context)\n                       : undefined\n            }, this);\n\n            return true;\n        } else {\n            return RB.BaseCollection.prototype.fetch.call(this, options,\n                                                          context);\n        }\n    },\n\n    /**\n     * Fetch the previous batch of models from the resource list.\n     *\n     * This requires hasPrev to be true, from a prior fetch.\n     *\n     * The collection's list of models will be replaced with the new list\n     * after the fetch succeeds. Each time fetchPrev is called, the collection\n     * will consist only of that page's batch of models. This can be overridden\n     * by providing `reset: false` in options.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the fetch operation.\n     *\n     *     context (object):\n     *         Context to bind when calling callbacks.\n     */\n    fetchPrev(options={}, context=undefined) {\n        if (!this.hasPrev) {\n            return false;\n        }\n\n        this._fetchURL = this._links.prev.href;\n\n        return this.fetch(\n            _.defaults({\n                page: this.currentPage - 1\n            }, options),\n            context);\n    },\n\n    /**\n     * Fetch the next batch of models from the resource list.\n     *\n     * This requires hasNext to be true, from a prior fetch.\n     *\n     * The collection's list of models will be replaced with the new list\n     * after the fetch succeeds. Each time fetchNext is called, the collection\n     * will consist only of that page's batch of models. This can be overridden\n     * by providing `reset: false` in options.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the fetch operation.\n     *\n     *     context (object):\n     *         Context to bind when calling callbacks.\n     */\n    fetchNext(options={}, context=undefined) {\n        if (!this.hasNext && options.enforceHasNext !== false) {\n            return false;\n        }\n\n        this._fetchURL = this._links.next.href;\n\n        return this.fetch(\n            _.defaults({\n                page: this.currentPage + 1\n            }, options),\n            context);\n    },\n\n    /**\n     * Fetch all models from the resource list.\n     *\n     * This will fetch all the models from a resource list on a server,\n     * paginating automatically until all models are fetched. The result is\n     * a list of models on the server.\n     *\n     * This differs from fetch/fetchPrev/fetchNext, which will replace the\n     * collection each time a page of resources are loaded.\n     *\n     * This can end up slowing down the server. Use it carefully.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the fetch operation.\n     *\n     *     context (object):\n     *         Context to bind when calling callbacks.\n     */\n    fetchAll(options={}, context=undefined) {\n        options = _.bindCallbacks(options, context);\n\n        const fetchOptions = _.defaults({\n            reset: false,\n            fetchingAll: true,\n            enforceHasNext: false,\n            maxResults: 50,\n            success: () => {\n                if (this._links.next) {\n                    this._fetchURL = this._links.next.href;\n                    this.fetchNext(fetchOptions, this);\n                } else if (_.isFunction(options.success)) {\n                    options.success(this, this.models, options);\n                }\n            }\n        }, options);\n\n        this._fetchURL = null;\n\n        this.reset();\n\n        return this.fetch(fetchOptions, this);\n    },\n\n    /**\n     * Prepare the model for the collection.\n     *\n     * This overrides Collection's _prepareModel to ensure that the resource\n     * has the proper parentObject set.\n     *\n     * Returns:\n     *     Backbone.Model:\n     *     The new model.\n     */\n    _prepareModel() {\n        const model = RB.BaseCollection.prototype._prepareModel.apply(this, arguments);\n\n        model.set('parentObject', this.parentResource);\n\n        return model;\n    }\n});\n"]}