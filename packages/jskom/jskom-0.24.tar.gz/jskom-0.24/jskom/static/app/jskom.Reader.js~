      var Reader = function(conn, unreadQueue, textsService) {
        this.conn = conn;
        this._unreadQueue = unreadQueue;
        this._textsService;
        this._pending = [];
      };
      
      _.extend(Reader.prototype, {
        unshiftPending: function() {
          this._pending.unshift.apply(this._pending, arguments);
        },
        
        pushPending: function() {
          this._pending.push.apply(this._pending, arguments);
        },
        
        shift: function() {
          this.conn.userIsActive();
          
          if (this.hasPending()) {
            return this._textsService.getText(this.conn, this._pending.shift());
            
          } else if (this.hasUnread()) {
            var self = this;
            return this._textsService.getText(this.conn, this._unreadQueue.dequeue()).then(
              function(text) {
                text._is_unread = true;
                markAsRead(self.conn, text);
                return text;
              });
          } else {
            return null;
          }
        },
        
        hasPending: function() {
          return this._pending.length > 0;
        },
        
        hasUnread: function() {
          return this.unreadSize() > 0;
        },
        
        size: function() {
          return this._pending.length + this._unreadQueue.size();
        },
        
        pendingSize: function() {
          return this._pending.length;
        },
        
        unreadSize: function() {
          return this._unreadQueue.size();
        },
        
        isEmpty: function() {
          return !(this.size() > 0);
        },


// The algorithm for finding the next unread text
// ----------------------------------------------
// 
// Reads threads depth-first. The thread stack is used to remember
// which other branches there were further up in the thread, so we know
// where to continue when the current branch ends.
// 
// 1. Pick the unread text:
//    
//    If {threadStack} is empty: 
//    
//      If {unreadTexts} is empty: there is no unread text.
//    
//      If {unreadTexts} is not empty: Pick the text with the lowest
//      text number as the unread text.
//    
//    If {threadStack} is not empty: pop a text and pick it as
//    the unread text.
// 
// 2. Follow the thread
//    
//    To follow the thread correctly, we need to fetch the text we
//    pick and push its unread comments onto the {threadStack}, in
//    reverse order (so we pick the first comment first).
// 
// 
// We return a promise for the unread text instead of the unread text,
// because we must get the unread comments before the /next/ unread
// text can be found. The typical usage is to read one text at a time,
// so we assume that the callee will fetch the text. This means that
// it is acceptable for us to not resolve the promise of the unread
// text until we've actually fetched the text.
// 
// When we have fetched the unread text, we resolve the promise and
// the callee can then fetch the text - which is now expected to be in
// the cache - and will get the text immediately.
// 
        getFirstUnreadText: function (unreadTextNos, threadStack) {
          var unreadTextNo = null;
          if (threadStack.length > 0) {
            // continue in thread
            unreadTextNo = threadStack.pop();
          } else if (unreadTextNos.length > 0) {
            // pick a new thread start
            unreadTextNo = _.min(unreadTextNos);
          }
          return unreadTextNo;
        },

        getUnreadComments: function (unreadTextNo, unreadTextNos, getTextPromiseFunc) {
          return getTextPromiseFunc(unreadTextNo).then(
            function(text) {
              var comments = _.map(text.comment_in_list, function(comment) {
                return comment.text_no;
              });
              
              if (comments != null && comments.length > 0) {
                // We filter instead of doing intersect because we need to
                // be sure that we preserve the order of the comments.
                var unreadComments = _.filter(comments, function(textNo) {
                  return _.include(unreadTextNos, textNo)
                });
                return unreadComments;
              } else {
                return [];
              }
            });
        },

        getNextUnreadText: function (unreadTextNos, threadStack, getTextPromiseFunc) {
          var deferred = $q.defer();
          var unreadTextNo = this.getFirstUnreadText(unreadTextNos, threadStack);
          if (unreadTextNo != null) {
            this.getUnreadComments(unreadTextNo, unreadTextNos, getTextPromiseFunc, $q).then(
              function(unreadComments) {
                unreadComments.reverse();
                _.each(unreadComments, function(textNo) {
                  threadStack.push(textNo);
                });
                deferred.resolve(unreadTextNo);
              },
              function(response) {
                deferred.reject(response);
              });
          } else {
            deferred.resolve(null);
          }
          return deferred.promise;
        }
      });
