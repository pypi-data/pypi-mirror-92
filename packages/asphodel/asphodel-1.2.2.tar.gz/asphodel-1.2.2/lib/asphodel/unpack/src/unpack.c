// AUTOGENERATED FILE. DO NOT MODIFY.

#include <stdlib.h>
#include <stdint.h>

#include "unpack.h"
#include "unpack_all_sizes.h"
#include "unwrap.h"
#include "unpack_id.h"


UNPACK_API unpack_func_t find_unpack(int count, int bits, int is_signed, int offset) {
	if (0 <= offset && offset <= 7) {
		switch (bits) {
			case 0:
				if (1 <= count && count <= UNPACK_0BIT_MAX_COUNT) {
					return unpack_0bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 1:
				if (1 <= count && count <= UNPACK_1BIT_MAX_COUNT) {
					return unpack_1bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 2:
				if (1 <= count && count <= UNPACK_2BIT_MAX_COUNT) {
					return unpack_2bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 3:
				if (1 <= count && count <= UNPACK_3BIT_MAX_COUNT) {
					return unpack_3bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 4:
				if (1 <= count && count <= UNPACK_4BIT_MAX_COUNT) {
					return unpack_4bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 5:
				if (1 <= count && count <= UNPACK_5BIT_MAX_COUNT) {
					return unpack_5bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 6:
				if (1 <= count && count <= UNPACK_6BIT_MAX_COUNT) {
					return unpack_6bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 7:
				if (1 <= count && count <= UNPACK_7BIT_MAX_COUNT) {
					return unpack_7bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 8:
				if (1 <= count && count <= UNPACK_8BIT_MAX_COUNT) {
					return unpack_8bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 9:
				if (1 <= count && count <= UNPACK_9BIT_MAX_COUNT) {
					return unpack_9bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 10:
				if (1 <= count && count <= UNPACK_10BIT_MAX_COUNT) {
					return unpack_10bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 11:
				if (1 <= count && count <= UNPACK_11BIT_MAX_COUNT) {
					return unpack_11bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 12:
				if (1 <= count && count <= UNPACK_12BIT_MAX_COUNT) {
					return unpack_12bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 13:
				if (1 <= count && count <= UNPACK_13BIT_MAX_COUNT) {
					return unpack_13bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 14:
				if (1 <= count && count <= UNPACK_14BIT_MAX_COUNT) {
					return unpack_14bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 15:
				if (1 <= count && count <= UNPACK_15BIT_MAX_COUNT) {
					return unpack_15bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 16:
				if (1 <= count && count <= UNPACK_16BIT_MAX_COUNT) {
					return unpack_16bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 17:
				if (1 <= count && count <= UNPACK_17BIT_MAX_COUNT) {
					return unpack_17bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 18:
				if (1 <= count && count <= UNPACK_18BIT_MAX_COUNT) {
					return unpack_18bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 19:
				if (1 <= count && count <= UNPACK_19BIT_MAX_COUNT) {
					return unpack_19bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 20:
				if (1 <= count && count <= UNPACK_20BIT_MAX_COUNT) {
					return unpack_20bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 21:
				if (1 <= count && count <= UNPACK_21BIT_MAX_COUNT) {
					return unpack_21bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 22:
				if (1 <= count && count <= UNPACK_22BIT_MAX_COUNT) {
					return unpack_22bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 23:
				if (1 <= count && count <= UNPACK_23BIT_MAX_COUNT) {
					return unpack_23bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 24:
				if (1 <= count && count <= UNPACK_24BIT_MAX_COUNT) {
					return unpack_24bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 25:
				if (1 <= count && count <= UNPACK_25BIT_MAX_COUNT) {
					return unpack_25bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 26:
				if (1 <= count && count <= UNPACK_26BIT_MAX_COUNT) {
					return unpack_26bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 27:
				if (1 <= count && count <= UNPACK_27BIT_MAX_COUNT) {
					return unpack_27bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 28:
				if (1 <= count && count <= UNPACK_28BIT_MAX_COUNT) {
					return unpack_28bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 29:
				if (1 <= count && count <= UNPACK_29BIT_MAX_COUNT) {
					return unpack_29bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 30:
				if (1 <= count && count <= UNPACK_30BIT_MAX_COUNT) {
					return unpack_30bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 31:
				if (1 <= count && count <= UNPACK_31BIT_MAX_COUNT) {
					return unpack_31bit[count - 1][offset][is_signed != 0];
				}
				break;
			case 32:
				if (1 <= count && count <= UNPACK_32BIT_MAX_COUNT) {
					return unpack_32bit[count - 1][offset][is_signed != 0];
				}
				break;
		}
	}

	return NULL;
}

UNPACK_API unwrap_func_t find_unwrap(int bits, int offset) {
	if (0 <= offset && offset <= 7) {
		if (UNWRAP_MIN_COUNT <= bits && bits <= UNWRAP_MAX_COUNT) {
			return unwrap[bits - UNWRAP_MIN_COUNT][offset];
		}
	}

	return NULL;
}

UNPACK_API unpack_id_func_t find_unpack_id(int bits, int offset) {
	if (0 <= offset && offset <= 7) {
		if (UNPACK_ID_MIN_COUNT <= bits && bits <= UNPACK_ID_MAX_COUNT) {
			return unpack_id[bits - UNPACK_ID_MIN_COUNT][offset];
		}
	}

	return NULL;
}
