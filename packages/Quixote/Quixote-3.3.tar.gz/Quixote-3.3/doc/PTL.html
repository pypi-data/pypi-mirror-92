<?xml version="1.0" encoding="us-ascii" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>PTL: Python Template Language</title>
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="ptl-python-template-language">
<h1 class="title">PTL: Python Template Language</h1>

<div class="section" id="introduction">
<h1>Introduction</h1>
<p>PTL is the templating language used by Quixote.  Most web templating
languages embed a real programming language in HTML, but PTL inverts
this model by merely tweaking Python to make it easier to generate
HTML pages (or other forms of text).  In other words, PTL is basically
Python with a novel way to specify function return values.</p>
<p>Specifically, a PTL template is designated by decorating a function with
the <cite>ptl_plain</cite> or <cite>ptl_html</cite> decorator (from the <cite>quixote.ptl</cite> module).
The value of expressions inside templates are kept, not discarded.  For
HTML templates, the return value from the function is a special string
type, which tracks HTML special character escaping (i.e.  special
characters are escaped exactly once).</p>
</div>
<div class="section" id="plain-text-templates">
<h1>Plain text templates</h1>
<p>Here's a sample plain text template:</p>
<pre class="literal-block">
from quixote.ptl import ptl_plain

&#64;ptl_plain
def foo(x, y = 5):
    &quot;This is a chunk of static text.&quot;
    greeting = &quot;hello world&quot; # statement, no PTL output
    print('Input values:', x, y)
    z = x + y
    &quot;&quot;&quot;You can plug in variables like x (%s)
in a variety of ways.&quot;&quot;&quot; % x

    &quot;\n\n&quot;
    &quot;Whitespace is important in generated text.\n&quot;
    &quot;z = &quot;; z
    &quot;, but y is &quot;
    y
    &quot;.&quot;
</pre>
<p>Obviously, templates can't have docstrings, but otherwise they follow
Python's syntactic rules: indentation indicates scoping, single-quoted
and triple-quoted strings can be used, the same rules for continuing
lines apply, and so forth.  PTL also follows all the expected semantics
of normal Python code: so templates can have parameters, and the
parameters can have default values, be treated as keyword arguments,
etc.</p>
<p>The difference between a template and a regular Python function is that
inside a template the result of expressions are saved as the return
value of that template.  Look at the first part of the example again:</p>
<pre class="literal-block">
&#64;ptl_plain
def foo(x, y=5):
    &quot;This is a chunk of static text.&quot;
    greeting = &quot;hello world&quot; # statement, no PTL output
    print('Input values:', x, y)
    z = x + y
    &quot;&quot;&quot;You can plug in variables like x (%s)
in a variety of ways.&quot;&quot;&quot; % x
</pre>
<p>Calling this template with <tt class="docutils literal">foo(1, 2)</tt> results in the following
string:</p>
<pre class="literal-block">
This is a chunk of static text.You can plug in variables like x (1)
in a variety of ways.
</pre>
<p>Normally when Python evaluates expressions inside functions, it just
discards their values, but in a plain text PTL template the value is
converted to a string using <tt class="docutils literal">str()</tt> and appended to the template's
return value.  There's a single exception to this rule: <tt class="docutils literal">None</tt> is the
only value that's ever ignored, adding nothing to the output.  (If this
weren't the case, calling methods or functions that return <tt class="docutils literal">None</tt>
would require assigning their value to a variable.  You'd have to write
<tt class="docutils literal">dummy = list.sort()</tt> in PTL code, which would be strange and
confusing.)</p>
<p>The initial string in a template isn't treated as a docstring, but is
just incorporated in the generated output; therefore, templates can't
have docstrings.  No whitespace is ever automatically added to the
output, resulting in <tt class="docutils literal"><span class="pre">...text.You</span> can ...</tt> from the example.  You'd
have to add an extra space to one of the string literals to correct
this.</p>
<p>The assignment to the <tt class="docutils literal">greeting</tt> local variable is a statement, not an
expression, so it doesn't return a value and produces no output.  The
output from the <tt class="docutils literal">print</tt> statement will be printed as usual, but won't
go into the string generated by the template.  Quixote directs standard
output into Quixote's debugging log; if you're using PTL on its own, you
should consider doing something similar.  <tt class="docutils literal">print</tt> should never be used
to generate output returned to the browser, only for adding debugging
traces to a template.</p>
<p>Inside templates, you can use all of Python's control-flow statements:</p>
<pre class="literal-block">
&#64;ptl_plain
def numbers(n):
    for i in range(n):
        i
        &quot; &quot; # PTL does not add any whitespace
</pre>
<p>Calling <tt class="docutils literal">numbers(5)</tt> will return the string <tt class="docutils literal">&quot;1 2 3 4 5 &quot;</tt>.  You can
also have conditional logic or exception blocks:</p>
<pre class="literal-block">
&#64;ptl_plain
def international_hello(language):
    if language == &quot;english&quot;:
        &quot;hello&quot;
    elif language == &quot;french&quot;:
        &quot;bonjour&quot;
    else:
        raise ValueError(&quot;I don't speak %s&quot; % language)
</pre>
</div>
<div class="section" id="html-templates">
<h1>HTML templates</h1>
<p>Since PTL is usually used to generate HTML documents, an HTML
template type has been provided to make generating HTML easier.</p>
<p>A common error when generating HTML is to grab data from the browser
or from a database and incorporate the contents without escaping
special characters such as '&lt;' and '&amp;'.  This leads to a class of
security bugs called &quot;cross-site scripting&quot; bugs, where a hostile user
can insert arbitrary HTML in your site's output that can link to other
sites or contain JavaScript code that does something nasty (say,
popping up 10,000 browser windows).</p>
<p>Such bugs occur because it's easy to forget to HTML-escape a string,
and forgetting it in just one location is enough to open a hole.  PTL
offers a solution to this problem by being able to escape strings
automatically when generating HTML output, at the cost of slightly
diminished performance (a few percent).</p>
<p>Here's how this feature works.  PTL defines a class called
<tt class="docutils literal">htmltext</tt> that represents a string that's already been HTML-escaped
and can be safely sent to the client.  The function <tt class="docutils literal">htmlescape(string)</tt>
is used to escape data, and it always returns an <tt class="docutils literal">htmltext</tt>
instance.  It does nothing if the argument is already <tt class="docutils literal">htmltext</tt>.</p>
<p>If a template function is decorated with <cite>ptl_html</cite> instead of
<cite>ptl_plain</cite> then the return value of the function becomes an 'htmltext'
instance.  <tt class="docutils literal">htmltext</tt> type is like the <tt class="docutils literal">str</tt> type except that
operations combining strings and <tt class="docutils literal">htmltext</tt> instances will result in
the string being passed through <tt class="docutils literal">htmlescape()</tt>.  For example:</p>
<pre class="literal-block">
&gt;&gt;&gt; from quixote.html import htmltext
&gt;&gt;&gt; htmltext('a') + 'b'
&lt;htmltext 'ab'&gt;
&gt;&gt;&gt; 'a' + htmltext('b')
&lt;htmltext 'ab'&gt;
&gt;&gt;&gt; htmltext('a%s') % 'b'
&lt;htmltext 'ab'&gt;
&gt;&gt;&gt; response = 'green eggs &amp; ham'
&gt;&gt;&gt; htmltext('The response was: %s') % response
&lt;htmltext 'The response was: green eggs &amp;amp; ham'&gt;
</pre>
<p>Note that calling <tt class="docutils literal">str()</tt> strips the <tt class="docutils literal">htmltext</tt> type and should be
avoided since it usually results in characters being escaped more than
once.</p>
<p>It is recommended that the <tt class="docutils literal">htmltext</tt> constructor be used as sparingly
as possible.  The reason is that when using the htmltext feature of PTL,
explicit calls to <tt class="docutils literal">htmltext</tt> become the most likely source of
cross-site scripting holes.  Calling <tt class="docutils literal">htmltext</tt> is like saying &quot;I am
absolutely sure this piece of data cannot contain malicious HTML code
injected by a user.  Don't escape HTML special characters because I want
them.&quot;</p>
<p>To include literal 'htmltext' data in .ptl modules, use the HTML f-string
notation (upper-case prefix).  For example:</p>
<blockquote>
<dl class="docutils">
<dt>def format_title(title):</dt>
<dd>return F'&lt;h1&gt;{title}&lt;/h1&gt;'</dd>
</dl>
</blockquote>
<p>The literal strings using the HTML f-string notation are htmltext
instances.  The <tt class="docutils literal">htmltext</tt> type prevents their contents from being
escaped by the <tt class="docutils literal">htmlescape</tt> function.  You will only need to use
<tt class="docutils literal">htmltext</tt> when HTML markup comes from outside the template.  For
example, if you want to include a file containing HTML:</p>
<pre class="literal-block">
&#64;ptl_html
def output_file():
    '&lt;html&gt;&lt;body&gt;' # does not get escaped
    with open('myfile.html') as fp:
        htmltext(fp.read())
    '&lt;/body&gt;&lt;/html&gt;'
</pre>
<p>In the common case, templates won't be dealing with HTML markup from
external sources, so you can write straightforward code.  Consider
this function to generate the contents of the <tt class="docutils literal">HEAD</tt> element:</p>
<pre class="literal-block">
&#64;ptl_html
def meta_tags(title, description):
    F'&lt;title&gt;{title}&lt;/title&gt;'
    F'&lt;meta name=&quot;description&quot; content=&quot;{description}&quot;&gt;\n'
</pre>
<p>There are no calls to <tt class="docutils literal">htmlescape()</tt> at all, but the HTML f-string
literals are <tt class="docutils literal">htmltext</tt> instances, so the data in the <cite>title</cite> and
<cite>description</cite> variables will automatically be escaped:</p>
<pre class="literal-block">
&gt;&gt;&gt; t.meta_tags('Catalog', 'A catalog of our cool products')
&lt;htmltext '&lt;title&gt;Catalog&lt;/title&gt;
  &lt;meta name=&quot;description&quot; content=&quot;A catalog of our cool products&quot;&gt;\n'&gt;
&gt;&gt;&gt; t.meta_tags('Dissertation on &lt;HEAD&gt;',
...             'Discusses the &quot;LINK&quot; and &quot;META&quot; tags')
&lt;htmltext '&lt;title&gt;Dissertation on &amp;lt;HEAD&amp;gt;&lt;/title&gt;
  &lt;meta name=&quot;description&quot;
   content=&quot;Discusses the &amp;quot;LINK&amp;quot; and &amp;quot;META&amp;quot; tags&quot;&gt;\n'&gt;
&gt;&gt;&gt;
</pre>
<p>Note how the title and description have had HTML-escaping applied to them.
(The output has been manually pretty-printed to be more readable.)</p>
<p>Two implementations of <tt class="docutils literal">htmltext</tt> are provided, one written in pure
Python and a second one implemented as a C extension.  Both versions
have seen production use.</p>
</div>
<div class="section" id="ptl-modules">
<h1>PTL modules</h1>
<p>PTL templates are kept in files with the extension .ptl.  Like Python
files, they are byte-compiled on import, and the byte-code is written to
a compiled file with the extension <tt class="docutils literal">.pyc</tt>.  Since vanilla Python
doesn't know anything about PTL, Quixote provides an import hook to let
you import PTL files just like regular Python modules.  The standard way
to install this import hook is by calling the <tt class="docutils literal">enable_ptl()</tt> function:</p>
<pre class="literal-block">
from quixote import enable_ptl
enable_ptl()
</pre>
<p>Once the import hook is installed, PTL files can be imported as if they
were Python modules.  If all the example templates shown here were put
into a file named <tt class="docutils literal">foo.ptl</tt>, you could then write Python code that did
this:</p>
<pre class="literal-block">
from foo import numbers
def f():
    return numbers(10)
</pre>
<p>You may want to keep this little function in your <tt class="docutils literal">PYTHONSTARTUP</tt>
file:</p>
<pre class="literal-block">
def ptl():
    from quixote import enable_ptl
    enable_ptl()
</pre>
<p>This is useful if you want to interactively play with a PTL module.</p>
</div>
</div>
</body>
</html>
