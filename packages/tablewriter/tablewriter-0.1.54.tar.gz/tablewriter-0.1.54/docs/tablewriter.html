<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>tablewriter.tablewriter API documentation</title>
<meta name="description" content="Created on some day of 2018 or 2019 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tablewriter.tablewriter</code></h1>
</header>
<section id="section-intro">
<p>Created on some day of 2018 or 2019.</p>
<p>@author: cottephi@gmail.com</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;Created on some day of 2018 or 2019.

@author: cottephi@gmail.com
&#34;&#34;&#34;

import os
import time
import tempfile
import dask.dataframe as dd
from transparentpath import TransparentPath as Path
from typing import Any, Dict, TypeVar, Union, Optional

import pandas as pd

T = TypeVar(&#34;T&#34;)
DONE = &#34;  ...done&#34;
LATEX_TEXT_COLOR = r&#34;\textcolor{&#34;


class TableWriter(object):
    &#34;&#34;&#34;Class used to produce a ready-to-compile .tex file containing a table from a pandas or dask DataFrame object.
    Can also compile the .tex to produce a .pdf.

    Handles using additional latex packages through the *packages* argument. The given DataFrame is copied so any
    modification of the  said DataFrame after instensiation of the TableWriter object has no effect on the
    TableWriter object, and vice-versa.
    You should not however modify the DataFrame contained in the TableWriter object, you should just create the
    TableWriter once you are sure that your DataFrame is ready.

    TableWriter uses pandas.DataFrame.to_latex and adds some more options to produce the .tex and the .pdf. Any
    option that must be given to the to_latex method can be given to TableWriter through the *to_latex_args*
    argument.

    Note that the content of the DataFrame will be converted to string. If the DataFrame contains one the following
    characters (&#34;$&#34;, &#34;_&#34;, &#34;^&#34;, &#34;%&#34;, &#34;&amp;&#34;), a &#39;\&#39; is put before them.
    Mathmode using &#39;$&#39; is handled.

    Examples
    --------

    &gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
    &gt;&gt;&gt; df = pd.DataFrame(columns=[&#34;$x$&#34;, &#34;$x^2$&#34;],  # doctest: +SKIP
    &gt;&gt;&gt;                   index=[&#34;$A_{00}$&#34;, &#34;$A_{01}$&#34;], data=[[2, 4], [3, 9]])  # doctest: +SKIP
    &gt;&gt;&gt; table = TableWriter(df, path=&#34;ouput&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; table.compile()  # doctest: +SKIP

    TableWriter will use os.system(&#39;pdflatex ...&#39;) to create the pdf, so you need a working installation of it.
    In order not to flood the stdout with pdflatex ouput, which is quite verbose, it is silenced by default. If the
    compilation fails TableWriter will return &#39;ValueError: Failed to compile pdf&#39;. In that case, you can try to
    recompile if using

    &gt;&gt;&gt; table.compile(silenced=False)  # doctest: +SKIP

    To have the full output and try to understand what went wrong.

    By default, all files produced by LaTeX are deleted except the .tex and the .pdf. You can change this default
    behavior :

    &gt;&gt;&gt; # To keep all files :  # doctest: +SKIP
    &gt;&gt;&gt; table.compile(clean=False)  # doctest: +SKIP
    &gt;&gt;&gt; # Or on the contrary, to remove also .tex :  # doctest: +SKIP
    &gt;&gt;&gt; table.compile(clean_tex=True)  # doctest: +SKIP

    You can also do a compilation that will reuse the .tex file if it already exists:

    &gt;&gt;&gt; table.compile(recreate=False)

    Here is a more complete example of table generation :

    &gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
    &gt;&gt;&gt; df = pd.DataFrame(columns=[&#34;$x$&#34;, &#34;$x^2$&#34;], index=[&#34;$A_{00}$&#34;, &#34;$A_{01}$&#34;],    # doctest: +SKIP
    &gt;&gt;&gt;                   data=[[&#34;2&#34;, &#34;$2^2$&#34;], [&#34;3&#34;, &#34;$3^2$&#34;]])  # doctest: +SKIP
    &gt;&gt;&gt; table = TableWriter(  # doctest: +SKIP
    &gt;&gt;&gt;     path=&#34;path_output&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;     data=df,  # doctest: +SKIP
    &gt;&gt;&gt;     to_latex_args={&#34;column_format&#34;: &#34;lr&#34;},  # doctest: +SKIP
    &gt;&gt;&gt;     label=&#34;tab::example&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;     caption=&#34;TableWriter example&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;     packages={&#34;inputenc&#34;: {&#34;T1&#34;: &#34;&#34;}},  # doctest: +SKIP
    &gt;&gt;&gt;     hide_numbering=True
    &gt;&gt;&gt; )  # doctest: +SKIP
    &gt;&gt;&gt; table.compile()  # doctest: +SKIP

    &#34;&#34;&#34;

    # //////////////////
    # // Initialisers //
    # //////////////////

    def __init__(
        self,
        path_output: Optional[Union[str, Path]] = None,
        data: Optional[Union[pd.DataFrame, dd.DataFrame]] = None,
        path_input: Optional[Union[str, Path]] = None,
        to_latex_args: Optional[Dict[str, Any]] = None,
        label: Optional[str] = None,
        caption: Optional[str] = None,
        packages: Dict[str, Union[None, Dict[str, Union[None, str]]]] = None,
        read_from_file_args: Dict = None,
        paperwidth: Union[int, float] = 0,
        paperheight: Union[int, float] = 0,
        number: int = 1,
        hide_numbering: bool = False,
    ):
        &#34;&#34;&#34;All parameters are optionnal and can be modified by dedicated
        setters.

        Parameters
        ----------
        path_output: Union[str, TransparentPath]
            Path to the .tex file to create. If the path&#39;s suffix is not .tex, it will be changed to .tex.
            You can set this path later using mytable.path = ... or mytable.path_output = ...
            (Default value = None)
        data: Union[pd.DataFrame, dd.DataFrame]
            Data to transform to table. Can not be specified alongside path_input. (Default value = None)
        path_input: Union[str, TransparentPath]
            Path to the file to use to read the DataFrame from. Can not be specified alongside data.
            (Default value = None)
        to_latex_args: Dict[str, Any]
            Dict of arguments to give to the DataFrame.to_latex method. See valid arguments at
            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_latex.html
            (Default value = None)
        label: str
            Label to use for the table (callable by LateX&#39;s \\ref)
            (Default value = None)
        caption: str
            Caption to use for the table
            (Default value = None)
        packages: Dict[str, Dict[str, str]]
            Packages to use. Keys of first dict are the package names. values are dict of option: value options to
            use with the package. Can be empty if no options are to be specified.
            (Default value = None)
        read_from_file_args: Dict
            Dict of argument to pass to the read method.
        paperwidth: Union[int, float]
            Width of the output table in the pdf. If 0, TableWriter will try to guess a default value from table
            content, but that is not very accurate. (Default value = 0)
         paperheight: Union[int, float]
            Height of the page of the output pdf. If table is too long to fit on the page, it will be split in
            several pages using longtable package. (Default value = 0)
         number: int
            Number LateX should show after &#39;Table&#39;.  (Default value = 1)
         hide_numbering: bool
            Do not show &#39;Table N&#39; in the caption. (Default value = False)
        &#34;&#34;&#34;

        if data is None and path_input is None:
            raise ValueError(&#34;You must give data or path_input argument.&#34;)
        if data is not None and path_input is not None:
            raise ValueError(&#34;You must give data or path_input argument, but not both.&#34;)

        if path_input is not None:
            if read_from_file_args is None:
                read_from_file_args = {}
            if not isinstance(path_input, Path):
                path_input = Path(path_input)
            data = path_input.read(**read_from_file_args)

        if isinstance(data, dd.DataFrame):
            data = data.head(len(data.index))

        if data is not None and not isinstance(data, pd.DataFrame):
            raise ValueError(&#34;Data must be a DataFrame&#34;)

        if packages is None:
            packages = {}
        if to_latex_args is None:
            to_latex_args = {}

        self.header = &#34;&#34;
        self.body = &#34;\\begin{document}\\end{document}&#34;
        self.footer = &#34;&#34;

        self.data = data
        self.to_latex_args = to_latex_args
        self.__path = path_output
        self.label = label
        self.caption = caption
        self.packages = packages

        self.paperwidth, self.paperheight = None, None
        self._get_dimensions(paperwidth, paperheight)
        self.number = number
        self.hide_numbering = hide_numbering

        self.special_char = [&#34;_&#34;, &#34;^&#34;, &#34;%&#34;, &#34;&amp;&#34;]

        if self.caption is not None:
            self.to_latex_args[&#34;caption&#34;] = self.caption
        if self.label is not None:
            self.to_latex_args[&#34;label&#34;] = self.label
        if &#34;column_format&#34; not in self.to_latex_args:
            self.to_latex_args[&#34;column_format&#34;] = &#34;|l|&#34; + len(self.data.columns) * &#34;c&#34; + &#34;|&#34;
        if &#34;escape&#34; not in self.to_latex_args:
            self.to_latex_args[&#34;escape&#34;] = True
        if &#34;longtable&#34; not in self.to_latex_args:
            self.to_latex_args[&#34;longtable&#34;] = True

        if &#34;geometry&#34; not in self.packages:
            self.packages[&#34;geometry&#34;] = {}
        if &#34;marging&#34; not in self.packages[&#34;geometry&#34;]:
            self.packages[&#34;geometry&#34;][&#34;margin&#34;] = &#34;0.5cm&#34;
        if &#34;paperwidth&#34; not in self.packages[&#34;geometry&#34;]:
            self.packages[&#34;geometry&#34;][&#34;paperwidth&#34;] = f&#34;{str(self.paperwidth)}cm&#34;
        if &#34;paperheight&#34; not in self.packages[&#34;geometry&#34;]:
            self.packages[&#34;geometry&#34;][&#34;paperheight&#34;] = f&#34;{str(self.paperheight)}cm&#34;
        if &#34;caption&#34; not in self.packages:
            self.packages[&#34;caption&#34;] = {}
        if &#34;xcolor&#34; not in self.packages:
            self.packages[&#34;xcolor&#34;] = {&#34;dvipsnames&#34;: None}
        if &#34;booktabs&#34; not in self.packages:
            self.packages[&#34;booktabs&#34;] = {}
        if &#34;inputenc&#34; not in self.packages:
            self.packages[&#34;inputenc&#34;] = {&#34;utf8&#34;: None}
        if &#34;longtable&#34; not in self.packages and self.to_latex_args[&#34;longtable&#34;] is True:
            self.packages[&#34;longtable&#34;] = {}

        if isinstance(self.number, str):
            self.number = int(self.number)
        if self.number &gt; 0:
            self.number -= 1
        self.number = str(int(self.number))

        if self.__path is not None:
            if not isinstance(self.__path, Path):
                self.__path = Path(self.__path)
            if self.__path.suffix != &#34;.tex&#34;:
                self.__path = self.__path.with_suffix(&#34;.tex&#34;)

    @property
    def path(self) -&gt; Path:
        return self.__path

    @property
    def path_output(self) -&gt; Path:
        return self.__path

    @path.setter
    def path(self, apath: Union[str, Path, None]):
        if apath is not None:
            if not isinstance(apath, Path):
                apath = Path(apath)
            if apath.suffix != &#34;.tex&#34;:
                apath = apath.with_suffix(&#34;.tex&#34;)
        self.__path = apath

    @path_output.setter
    def path_output(self, apath: Union[str, Path, None]):
        self.path = apath

    # ////////////
    # // Makers //
    # ////////////

    def _get_dimensions(self, paperwidth, paperheight):

        self.paperwidth = paperwidth
        self.paperheight = paperheight

        if self.paperwidth != 0 and self.paperheight != 0:
            return

        # Try to guess a kind of optimal width for the table
        if not self.data.empty:
            charswidth = (
                len(&#34;&#34;.join(list(self.data.columns.dropna().astype(str))))
                + max([len(ind) for ind in self.data.index.dropna().astype(str)])
            ) * 0.178
            self.paperwidth = charswidth + 0.8 * (len(self.data.columns)) + 1
            if self.paperwidth &lt; 9:
                self.paperwidth = 9
        # Same for height
        if not self.data.empty:
            self.paperheight = 3.5 + (len(self.data.index)) * 0.45
            if self.paperheight &lt; 4:
                self.paperheight = 4
            if self.paperheight &gt; 24:
                # Limit page height to A4&#39;s 24 cm
                self.paperheight = 24
                self.to_latex_args[&#34;longtable&#34;] = True
            else:
                self.to_latex_args[&#34;longtable&#34;] = False

    def _make_header(self) -&gt; None:
        &#34;&#34;&#34;Makes the header of the tex file.&#34;&#34;&#34;

        self.header = &#34;\\documentclass{article}\n&#34;

        # Add specified packages if any
        for p in self.packages:
            if len(self.packages[p]) == 0:
                self.header += p.join([&#34;\\usepackage{&#34;, &#34;}\n&#34;])
            else:
                self.header += &#34;\\usepackage[&#34;
                for o in self.packages[p]:
                    if self.packages[p][o] is None:
                        self.header += o + &#34;,&#34;

                    else:
                        self.header += o + &#34;=&#34; + self.packages[p][o] + &#34;,&#34;
                self.header = self.header[:-1] + &#34;]{&#34; + p + &#34;}\n&#34;
        self.header += &#34;\\begin{document}\n\\nonstopmode\n\\setcounter{table}{&#34; + self.number + &#34;}\n&#34;

    def _make_body(self) -&gt; None:
        &#34;&#34;&#34;Makes the main body of tex file.&#34;&#34;&#34;

        # Needed if you do not want long names to be truncated with &#34;...&#34;
        # by pandas, giving bullshit results in the .tex file
        def_max_col = pd.get_option(&#34;display.max_colwidth&#34;)
        if pd.__version__.split(&#34;.&#34;)[0] == &#34;0&#34;:
            # pandas is older than 1.0.0
            pd.set_option(&#34;display.max_colwidth&#34;, -1)
        else:
            # pandas is 1.0.0 or newer
            pd.set_option(&#34;display.max_colwidth&#34;, None)

        if self.data.empty:
            self.body = self.caption + &#34;: Empty Dataframe\n&#34;
            return
        else:
            self.body = self.data.to_latex(**self.to_latex_args)
        pd.set_option(&#34;display.max_colwidth&#34;, def_max_col)

        if self.caption is not None and self.hide_numbering:
            self.body = self.body.replace(&#34;\\caption{&#34;, &#34;\\caption*{&#34;)

        if self.caption is not None or self.label is not None:
            self.body = self.body.replace(&#34;\n\\toprule&#34;, &#34;\\\\\n\\toprule&#34;)
        self.body = self.body.replace(&#34;\\\\\\\\&#34;, &#34;\\\\&#34;)

    def _make_footer(self) -&gt; None:
        &#34;&#34;&#34;Makes the footer of tex file.&#34;&#34;&#34;

        self.footer = &#34;\\end{document}\n&#34;

    def _escape_special_chars(self, s: T) -&gt; T:
        &#34;&#34;&#34;Will add &#39;\\&#39; before special characters outside of mathmode to given
        string.

        Parameters
        ----------
        s: T
            If s is not a string, will return it without changing anything

        Returns
        -------
        T
            String with special char escaped, or unmodified non-string object
        &#34;&#34;&#34;

        if not isinstance(s, str):
            return s
        in_math = False
        previous_c = &#34;&#34;
        s2 = &#34;&#34;
        for c in s:
            if c == &#34;$&#34;:
                in_math = not in_math
            if in_math:
                s2 += c
                previous_c = c
                continue
            if c in self.special_char and not previous_c == &#34;\\&#34;:
                c = &#34;\\&#34; + c
            previous_c = c
            s2 += c
        return s2

    # //////////////////
    # // Output files //
    # //////////////////

    def build(self):
        &#34;&#34;&#34;build header body and footer.&#34;&#34;&#34;
        if &#34;escape&#34; in self.to_latex_args and self.to_latex_args[&#34;escape&#34;]:
            self.data.index = [self._escape_special_chars(s) for s in self.data.index]
            self.data.columns = [self._escape_special_chars(s) for s in self.data.columns]
            self.data = self.data.applymap(self._escape_special_chars)
        self.to_latex_args[&#34;escape&#34;] = False
        self._make_header()
        self._make_body()
        self._make_footer()

    def create_tex_file(self) -&gt; None:
        &#34;&#34;&#34;Creates the tex file.&#34;&#34;&#34;

        with open(self.__path, &#34;w&#34;) as outfile:
            # escape argument only works on column names. We need to apply
            # it on entier DataFrame, so do that then set it to False
            self.build()
            outfile.write(self.header)
            outfile.write(self.body)
            outfile.write(self.footer)

    # noinspection StandardShellInjection
    def compile(
        self, silenced: bool = True, recreate: bool = True, clean: bool = True, clean_tex: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Compile the pdf.

        Parameters
        ----------
        silenced: bool
            Will or will not print on terminal the pdflatex output. (Default value = True)
        recreate: bool
            If False and .tex file exists, compile from it. If True, recreate the .tex file first.
        clean: bool
            Removes all files created by the compilation which are not the .tex or the .pdf file.
        clean_tex: bool
            Also removes the .tex file, leaving only the .pdf.

        Returns
        -------
        None
        &#34;&#34;&#34;

        if self.__path is None:
            raise ValueError(&#34;Must specify a file path.&#34;)
        if recreate or not self.__path.is_file():
            self.create_tex_file()

        if not self.__path.is_file():
            raise ValueError(f&#34;Tex file {self.__path} not found.&#34;)

        path_to_compile = self.__path
        if self.__path.fs_kind == &#34;gcs&#34;:
            path_to_compile = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.tex&#34;)
            path_to_compile.close()
            self.__path.get(path_to_compile.name)
            path_to_compile = Path(path_to_compile.name, fs=&#34;local&#34;)

        command = &#34;pdflatex -synctex=1 -interaction=nonstopmode &#34;
        parent = path_to_compile.parent
        if parent != &#34;.&#34;:
            command = f&#34;{command} -output-directory=\&#34;{parent}\&#34;&#34;

        command = f&#34;{command} \&#34;{path_to_compile}\&#34;&#34;
        if silenced:  # unix
            if os.name == &#34;posix&#34;:
                command = f&#34;{command} &gt; /dev/null&#34;
            else:  # windows
                command = f&#34;{command} &gt; NUL&#34;
        x1 = os.system(command)
        time.sleep(0.5)
        x2 = os.system(command)
        time.sleep(0.5)
        x3 = os.system(command)

        if self.__path.fs_kind == &#34;gcs&#34;:
            for path in path_to_compile.with_suffix(&#34;&#34;).glob(&#34;*&#34;):
                path_gcs = self.__path.with_suffix(path.suffix)
                path.put(path_gcs)
                path.rm()

        if x1 != 0 or x2 != 0 or x3 != 0:
            raise ValueError(&#34;Failed to compile pdf&#34;)

        if clean:
            self.clean(clean_tex)

    def clean(self, clean_tex: bool = False) -&gt; None:
        &#34;&#34;&#34;Clean files produced by latex. Also remove .tex if clean_tex is
        True.

        Parameters
        ---------
        clean_tex: bool
            To also remove the .tex file

        Returns
        -------
        None
        &#34;&#34;&#34;
        to_keep = [&#34;.pdf&#34;, &#34;.csv&#34;, &#34;.excel&#34;]
        if not clean_tex:
            to_keep.append(&#34;.tex&#34;)
        files = self.__path.with_suffix(&#34;&#34;).glob(&#34;*&#34;)
        for f in files:
            if f.suffix not in to_keep:
                f.rm()


def remove_color(obj: str) -&gt; str:
    &#34;&#34;&#34;Remove coloration of given object.

    Parameters
    ----------
    obj: str
        The object from which to remove the color

    Return
    ------
    str
        Object without color
    &#34;&#34;&#34;

    if LATEX_TEXT_COLOR not in obj:
        return obj
    to_find = LATEX_TEXT_COLOR
    before_color = obj[: obj.find(to_find)]
    after_color = obj[obj.find(&#34;textcolor&#34;) + 10:]
    no_color = after_color[after_color.find(&#34;{&#34;) + 1:].replace(&#34;}&#34;, &#34;&#34;, 1)
    return before_color + no_color


def set_color(obj: Any, color: str) -&gt; str:
    &#34;&#34;&#34;Add color to a given object.

    Parameters
    ----------
    obj : Any
        The object to which color must be added.
    color: str
        Must be a valid LateX color string

    Return
    ------
    str
        &#34;\\textcolor{color}{str(obj)}&#34;
    &#34;&#34;&#34;
    if pd.isna(obj):
        return obj
    return LATEX_TEXT_COLOR + color + &#34;}{&#34; + str(obj) + &#34;}&#34;


# noinspection PyTypeChecker
def set_color_dataframe(
    df: Union[pd.DataFrame, pd.Series], color: str, color_index: bool = False, color_columns: bool = False,
) -&gt; Union[pd.DataFrame, pd.Series]:
    r&#34;&#34;&#34;Sets color for the entier DataFrame&#39;s or Series&#39;s entries.

    To change the color of some elements in the dataframe under some condition

    Parameters
    ----------
    df: Union[pd.DataFrame, pd.Series]
        The DataFrame or Series to change the colors of
    color: str
        LateX-recognized color string
        Default &#39;&#39;
    color_index: bool
        To color the index too
        Default False.
    color_columns: str
        To color the columns (or Series name if df is a Series) too
        Default False.
    color_index: bool
        whether to color index or not
    color_columns: bool
        whether to color columns or not

    Returns
    -------
    Union[pd.DataFrame, pd.Series]
        Colored DataFrame or Series (dtype will be str)

    Examples
    --------

    dff = dff.mask(dff &lt; 0, TableWriter.set_color_dataframe(dff, &#34;red&#34;))
    dff = pd.DataFrame(columns=dff.columns, index=dff.index, data=dff.values.astype(str))
    dff = dff.mask(dff == &#34;nan&#34;, &#34;&#34;)
    writer = TableWriter(data=dff)

    &#34;&#34;&#34;
    if isinstance(df, pd.DataFrame):
        df_c = df.applymap(lambda x: set_color(x, color))
    else:
        df_c = df.apply(lambda x: set_color(x, color))
    if color_index:
        df_c.index = [set_color(x, color) for x in df_c.index]
    if color_columns:
        if isinstance(df, pd.DataFrame):
            df_c.columns = [set_color(x, color) for x in df_c.columns]
        else:
            df_c.name = set_color(df_c.name, color)
    return df_c</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tablewriter.tablewriter.remove_color"><code class="name flex">
<span>def <span class="ident">remove_color</span></span>(<span>obj: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove coloration of given object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>str</code></dt>
<dd>The object from which to remove the color</dd>
</dl>
<h2 id="return">Return</h2>
<p>str
Object without color</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_color(obj: str) -&gt; str:
    &#34;&#34;&#34;Remove coloration of given object.

    Parameters
    ----------
    obj: str
        The object from which to remove the color

    Return
    ------
    str
        Object without color
    &#34;&#34;&#34;

    if LATEX_TEXT_COLOR not in obj:
        return obj
    to_find = LATEX_TEXT_COLOR
    before_color = obj[: obj.find(to_find)]
    after_color = obj[obj.find(&#34;textcolor&#34;) + 10:]
    no_color = after_color[after_color.find(&#34;{&#34;) + 1:].replace(&#34;}&#34;, &#34;&#34;, 1)
    return before_color + no_color</code></pre>
</details>
</dd>
<dt id="tablewriter.tablewriter.set_color"><code class="name flex">
<span>def <span class="ident">set_color</span></span>(<span>obj: Any, color: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Add color to a given object.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>obj</code></strong> :&ensp;<code>Any</code></dt>
<dd>The object to which color must be added.</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>Must be a valid LateX color string</dd>
</dl>
<h2 id="return">Return</h2>
<p>str
"\textcolor{color}{str(obj)}"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_color(obj: Any, color: str) -&gt; str:
    &#34;&#34;&#34;Add color to a given object.

    Parameters
    ----------
    obj : Any
        The object to which color must be added.
    color: str
        Must be a valid LateX color string

    Return
    ------
    str
        &#34;\\textcolor{color}{str(obj)}&#34;
    &#34;&#34;&#34;
    if pd.isna(obj):
        return obj
    return LATEX_TEXT_COLOR + color + &#34;}{&#34; + str(obj) + &#34;}&#34;</code></pre>
</details>
</dd>
<dt id="tablewriter.tablewriter.set_color_dataframe"><code class="name flex">
<span>def <span class="ident">set_color_dataframe</span></span>(<span>df: Union[pandas.core.frame.DataFrame, pandas.core.series.Series], color: str, color_index: bool = False, color_columns: bool = False) ‑> Union[pandas.core.frame.DataFrame, pandas.core.series.Series]</span>
</code></dt>
<dd>
<div class="desc"><p>Sets color for the entier DataFrame's or Series's entries.</p>
<p>To change the color of some elements in the dataframe under some condition</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>df</code></strong> :&ensp;<code>Union[pd.DataFrame, pd.Series]</code></dt>
<dd>The DataFrame or Series to change the colors of</dd>
<dt><strong><code>color</code></strong> :&ensp;<code>str</code></dt>
<dd>LateX-recognized color string
Default ''</dd>
<dt><strong><code>color_index</code></strong> :&ensp;<code>bool</code></dt>
<dd>To color the index too
Default False.</dd>
<dt><strong><code>color_columns</code></strong> :&ensp;<code>str</code></dt>
<dd>To color the columns (or Series name if df is a Series) too
Default False.</dd>
<dt><strong><code>color_index</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to color index or not</dd>
<dt><strong><code>color_columns</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to color columns or not</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[pd.DataFrame, pd.Series]</code></dt>
<dd>Colored DataFrame or Series (dtype will be str)</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>dff = dff.mask(dff &lt; 0, TableWriter.set_color_dataframe(dff, "red"))
dff = pd.DataFrame(columns=dff.columns, index=dff.index, data=dff.values.astype(str))
dff = dff.mask(dff == "nan", "")
writer = TableWriter(data=dff)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_color_dataframe(
    df: Union[pd.DataFrame, pd.Series], color: str, color_index: bool = False, color_columns: bool = False,
) -&gt; Union[pd.DataFrame, pd.Series]:
    r&#34;&#34;&#34;Sets color for the entier DataFrame&#39;s or Series&#39;s entries.

    To change the color of some elements in the dataframe under some condition

    Parameters
    ----------
    df: Union[pd.DataFrame, pd.Series]
        The DataFrame or Series to change the colors of
    color: str
        LateX-recognized color string
        Default &#39;&#39;
    color_index: bool
        To color the index too
        Default False.
    color_columns: str
        To color the columns (or Series name if df is a Series) too
        Default False.
    color_index: bool
        whether to color index or not
    color_columns: bool
        whether to color columns or not

    Returns
    -------
    Union[pd.DataFrame, pd.Series]
        Colored DataFrame or Series (dtype will be str)

    Examples
    --------

    dff = dff.mask(dff &lt; 0, TableWriter.set_color_dataframe(dff, &#34;red&#34;))
    dff = pd.DataFrame(columns=dff.columns, index=dff.index, data=dff.values.astype(str))
    dff = dff.mask(dff == &#34;nan&#34;, &#34;&#34;)
    writer = TableWriter(data=dff)

    &#34;&#34;&#34;
    if isinstance(df, pd.DataFrame):
        df_c = df.applymap(lambda x: set_color(x, color))
    else:
        df_c = df.apply(lambda x: set_color(x, color))
    if color_index:
        df_c.index = [set_color(x, color) for x in df_c.index]
    if color_columns:
        if isinstance(df, pd.DataFrame):
            df_c.columns = [set_color(x, color) for x in df_c.columns]
        else:
            df_c.name = set_color(df_c.name, color)
    return df_c</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="tablewriter.tablewriter.TableWriter"><code class="flex name class">
<span>class <span class="ident">TableWriter</span></span>
<span>(</span><span>path_output: Union[str, transparentpath.gcsutils.transparentpath.TransparentPath, NoneType] = None, data: Union[pandas.core.frame.DataFrame, dask.dataframe.core.DataFrame, NoneType] = None, path_input: Union[str, transparentpath.gcsutils.transparentpath.TransparentPath, NoneType] = None, to_latex_args: Union[Dict[str, Any], NoneType] = None, label: Union[str, NoneType] = None, caption: Union[str, NoneType] = None, packages: Dict[str, Union[NoneType, Dict[str, Union[str, NoneType]]]] = None, read_from_file_args: Dict = None, paperwidth: Union[int, float] = 0, paperheight: Union[int, float] = 0, number: int = 1, hide_numbering: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class used to produce a ready-to-compile .tex file containing a table from a pandas or dask DataFrame object.
Can also compile the .tex to produce a .pdf.</p>
<p>Handles using additional latex packages through the <em>packages</em> argument. The given DataFrame is copied so any
modification of the
said DataFrame after instensiation of the TableWriter object has no effect on the
TableWriter object, and vice-versa.
You should not however modify the DataFrame contained in the TableWriter object, you should just create the
TableWriter once you are sure that your DataFrame is ready.</p>
<p>TableWriter uses pandas.DataFrame.to_latex and adds some more options to produce the .tex and the .pdf. Any
option that must be given to the to_latex method can be given to TableWriter through the <em>to_latex_args</em>
argument.</p>
<p>Note that the content of the DataFrame will be converted to string. If the DataFrame contains one the following
characters ("$", "_", "^", "%", "&amp;"), a '' is put before them.
Mathmode using '$' is handled.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
&gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
&gt;&gt;&gt; df = pd.DataFrame(columns=[&quot;$x$&quot;, &quot;$x^2$&quot;],  # doctest: +SKIP
&gt;&gt;&gt;                   index=[&quot;$A_{00}$&quot;, &quot;$A_{01}$&quot;], data=[[2, 4], [3, 9]])  # doctest: +SKIP
&gt;&gt;&gt; table = TableWriter(df, path=&quot;ouput&quot;)  # doctest: +SKIP
&gt;&gt;&gt; table.compile()  # doctest: +SKIP
</code></pre>
<p>TableWriter will use os.system('pdflatex &hellip;') to create the pdf, so you need a working installation of it.
In order not to flood the stdout with pdflatex ouput, which is quite verbose, it is silenced by default. If the
compilation fails TableWriter will return 'ValueError: Failed to compile pdf'. In that case, you can try to
recompile if using</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; table.compile(silenced=False)  # doctest: +SKIP
</code></pre>
<p>To have the full output and try to understand what went wrong.</p>
<p>By default, all files produced by LaTeX are deleted except the .tex and the .pdf. You can change this default
behavior :</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # To keep all files :  # doctest: +SKIP
&gt;&gt;&gt; table.compile(clean=False)  # doctest: +SKIP
&gt;&gt;&gt; # Or on the contrary, to remove also .tex :  # doctest: +SKIP
&gt;&gt;&gt; table.compile(clean_tex=True)  # doctest: +SKIP
</code></pre>
<p>You can also do a compilation that will reuse the .tex file if it already exists:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; table.compile(recreate=False)
</code></pre>
<p>Here is a more complete example of table generation :</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
&gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
&gt;&gt;&gt; df = pd.DataFrame(columns=[&quot;$x$&quot;, &quot;$x^2$&quot;], index=[&quot;$A_{00}$&quot;, &quot;$A_{01}$&quot;],    # doctest: +SKIP
&gt;&gt;&gt;                   data=[[&quot;2&quot;, &quot;$2^2$&quot;], [&quot;3&quot;, &quot;$3^2$&quot;]])  # doctest: +SKIP
&gt;&gt;&gt; table = TableWriter(  # doctest: +SKIP
&gt;&gt;&gt;     path=&quot;path_output&quot;,  # doctest: +SKIP
&gt;&gt;&gt;     data=df,  # doctest: +SKIP
&gt;&gt;&gt;     to_latex_args={&quot;column_format&quot;: &quot;lr&quot;},  # doctest: +SKIP
&gt;&gt;&gt;     label=&quot;tab::example&quot;,  # doctest: +SKIP
&gt;&gt;&gt;     caption=&quot;TableWriter example&quot;,  # doctest: +SKIP
&gt;&gt;&gt;     packages={&quot;inputenc&quot;: {&quot;T1&quot;: &quot;&quot;}},  # doctest: +SKIP
&gt;&gt;&gt;     hide_numbering=True
&gt;&gt;&gt; )  # doctest: +SKIP
&gt;&gt;&gt; table.compile()  # doctest: +SKIP
</code></pre>
<p>All parameters are optionnal and can be modified by dedicated
setters.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>path_output</code></strong> :&ensp;<code>Union[str, TransparentPath]</code></dt>
<dd>Path to the .tex file to create. If the path's suffix is not .tex, it will be changed to .tex.
You can set this path later using mytable.path = &hellip; or mytable.path_output = &hellip;
(Default value = None)</dd>
<dt><strong><code>data</code></strong> :&ensp;<code>Union[pd.DataFrame, dd.DataFrame]</code></dt>
<dd>Data to transform to table. Can not be specified alongside path_input. (Default value = None)</dd>
<dt><strong><code>path_input</code></strong> :&ensp;<code>Union[str, TransparentPath]</code></dt>
<dd>Path to the file to use to read the DataFrame from. Can not be specified alongside data.
(Default value = None)</dd>
<dt><strong><code>to_latex_args</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Dict of arguments to give to the DataFrame.to_latex method. See valid arguments at
<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_latex.html">https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_latex.html</a>
(Default value = None)</dd>
<dt><strong><code>label</code></strong> :&ensp;<code>str</code></dt>
<dd>Label to use for the table (callable by LateX's \ref)
(Default value = None)</dd>
<dt><strong><code>caption</code></strong> :&ensp;<code>str</code></dt>
<dd>Caption to use for the table
(Default value = None)</dd>
<dt><strong><code>packages</code></strong> :&ensp;<code>Dict[str, Dict[str, str]]</code></dt>
<dd>Packages to use. Keys of first dict are the package names. values are dict of option: value options to
use with the package. Can be empty if no options are to be specified.
(Default value = None)</dd>
<dt><strong><code>read_from_file_args</code></strong> :&ensp;<code>Dict</code></dt>
<dd>Dict of argument to pass to the read method.</dd>
<dt><strong><code>paperwidth</code></strong> :&ensp;<code>Union[int, float]</code></dt>
<dd>Width of the output table in the pdf. If 0, TableWriter will try to guess a default value from table
content, but that is not very accurate. (Default value = 0)</dd>
</dl>
<p>paperheight: Union[int, float]
Height of the page of the output pdf. If table is too long to fit on the page, it will be split in
several pages using longtable package. (Default value = 0)
number: int
Number LateX should show after 'Table'.
(Default value = 1)
hide_numbering: bool
Do not show 'Table N' in the caption. (Default value = False)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TableWriter(object):
    &#34;&#34;&#34;Class used to produce a ready-to-compile .tex file containing a table from a pandas or dask DataFrame object.
    Can also compile the .tex to produce a .pdf.

    Handles using additional latex packages through the *packages* argument. The given DataFrame is copied so any
    modification of the  said DataFrame after instensiation of the TableWriter object has no effect on the
    TableWriter object, and vice-versa.
    You should not however modify the DataFrame contained in the TableWriter object, you should just create the
    TableWriter once you are sure that your DataFrame is ready.

    TableWriter uses pandas.DataFrame.to_latex and adds some more options to produce the .tex and the .pdf. Any
    option that must be given to the to_latex method can be given to TableWriter through the *to_latex_args*
    argument.

    Note that the content of the DataFrame will be converted to string. If the DataFrame contains one the following
    characters (&#34;$&#34;, &#34;_&#34;, &#34;^&#34;, &#34;%&#34;, &#34;&amp;&#34;), a &#39;\&#39; is put before them.
    Mathmode using &#39;$&#39; is handled.

    Examples
    --------

    &gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
    &gt;&gt;&gt; df = pd.DataFrame(columns=[&#34;$x$&#34;, &#34;$x^2$&#34;],  # doctest: +SKIP
    &gt;&gt;&gt;                   index=[&#34;$A_{00}$&#34;, &#34;$A_{01}$&#34;], data=[[2, 4], [3, 9]])  # doctest: +SKIP
    &gt;&gt;&gt; table = TableWriter(df, path=&#34;ouput&#34;)  # doctest: +SKIP
    &gt;&gt;&gt; table.compile()  # doctest: +SKIP

    TableWriter will use os.system(&#39;pdflatex ...&#39;) to create the pdf, so you need a working installation of it.
    In order not to flood the stdout with pdflatex ouput, which is quite verbose, it is silenced by default. If the
    compilation fails TableWriter will return &#39;ValueError: Failed to compile pdf&#39;. In that case, you can try to
    recompile if using

    &gt;&gt;&gt; table.compile(silenced=False)  # doctest: +SKIP

    To have the full output and try to understand what went wrong.

    By default, all files produced by LaTeX are deleted except the .tex and the .pdf. You can change this default
    behavior :

    &gt;&gt;&gt; # To keep all files :  # doctest: +SKIP
    &gt;&gt;&gt; table.compile(clean=False)  # doctest: +SKIP
    &gt;&gt;&gt; # Or on the contrary, to remove also .tex :  # doctest: +SKIP
    &gt;&gt;&gt; table.compile(clean_tex=True)  # doctest: +SKIP

    You can also do a compilation that will reuse the .tex file if it already exists:

    &gt;&gt;&gt; table.compile(recreate=False)

    Here is a more complete example of table generation :

    &gt;&gt;&gt; from tablewriter import TableWriter  # doctest: +SKIP
    &gt;&gt;&gt; import pandas as pd  # doctest: +SKIP
    &gt;&gt;&gt; df = pd.DataFrame(columns=[&#34;$x$&#34;, &#34;$x^2$&#34;], index=[&#34;$A_{00}$&#34;, &#34;$A_{01}$&#34;],    # doctest: +SKIP
    &gt;&gt;&gt;                   data=[[&#34;2&#34;, &#34;$2^2$&#34;], [&#34;3&#34;, &#34;$3^2$&#34;]])  # doctest: +SKIP
    &gt;&gt;&gt; table = TableWriter(  # doctest: +SKIP
    &gt;&gt;&gt;     path=&#34;path_output&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;     data=df,  # doctest: +SKIP
    &gt;&gt;&gt;     to_latex_args={&#34;column_format&#34;: &#34;lr&#34;},  # doctest: +SKIP
    &gt;&gt;&gt;     label=&#34;tab::example&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;     caption=&#34;TableWriter example&#34;,  # doctest: +SKIP
    &gt;&gt;&gt;     packages={&#34;inputenc&#34;: {&#34;T1&#34;: &#34;&#34;}},  # doctest: +SKIP
    &gt;&gt;&gt;     hide_numbering=True
    &gt;&gt;&gt; )  # doctest: +SKIP
    &gt;&gt;&gt; table.compile()  # doctest: +SKIP

    &#34;&#34;&#34;

    # //////////////////
    # // Initialisers //
    # //////////////////

    def __init__(
        self,
        path_output: Optional[Union[str, Path]] = None,
        data: Optional[Union[pd.DataFrame, dd.DataFrame]] = None,
        path_input: Optional[Union[str, Path]] = None,
        to_latex_args: Optional[Dict[str, Any]] = None,
        label: Optional[str] = None,
        caption: Optional[str] = None,
        packages: Dict[str, Union[None, Dict[str, Union[None, str]]]] = None,
        read_from_file_args: Dict = None,
        paperwidth: Union[int, float] = 0,
        paperheight: Union[int, float] = 0,
        number: int = 1,
        hide_numbering: bool = False,
    ):
        &#34;&#34;&#34;All parameters are optionnal and can be modified by dedicated
        setters.

        Parameters
        ----------
        path_output: Union[str, TransparentPath]
            Path to the .tex file to create. If the path&#39;s suffix is not .tex, it will be changed to .tex.
            You can set this path later using mytable.path = ... or mytable.path_output = ...
            (Default value = None)
        data: Union[pd.DataFrame, dd.DataFrame]
            Data to transform to table. Can not be specified alongside path_input. (Default value = None)
        path_input: Union[str, TransparentPath]
            Path to the file to use to read the DataFrame from. Can not be specified alongside data.
            (Default value = None)
        to_latex_args: Dict[str, Any]
            Dict of arguments to give to the DataFrame.to_latex method. See valid arguments at
            https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.to_latex.html
            (Default value = None)
        label: str
            Label to use for the table (callable by LateX&#39;s \\ref)
            (Default value = None)
        caption: str
            Caption to use for the table
            (Default value = None)
        packages: Dict[str, Dict[str, str]]
            Packages to use. Keys of first dict are the package names. values are dict of option: value options to
            use with the package. Can be empty if no options are to be specified.
            (Default value = None)
        read_from_file_args: Dict
            Dict of argument to pass to the read method.
        paperwidth: Union[int, float]
            Width of the output table in the pdf. If 0, TableWriter will try to guess a default value from table
            content, but that is not very accurate. (Default value = 0)
         paperheight: Union[int, float]
            Height of the page of the output pdf. If table is too long to fit on the page, it will be split in
            several pages using longtable package. (Default value = 0)
         number: int
            Number LateX should show after &#39;Table&#39;.  (Default value = 1)
         hide_numbering: bool
            Do not show &#39;Table N&#39; in the caption. (Default value = False)
        &#34;&#34;&#34;

        if data is None and path_input is None:
            raise ValueError(&#34;You must give data or path_input argument.&#34;)
        if data is not None and path_input is not None:
            raise ValueError(&#34;You must give data or path_input argument, but not both.&#34;)

        if path_input is not None:
            if read_from_file_args is None:
                read_from_file_args = {}
            if not isinstance(path_input, Path):
                path_input = Path(path_input)
            data = path_input.read(**read_from_file_args)

        if isinstance(data, dd.DataFrame):
            data = data.head(len(data.index))

        if data is not None and not isinstance(data, pd.DataFrame):
            raise ValueError(&#34;Data must be a DataFrame&#34;)

        if packages is None:
            packages = {}
        if to_latex_args is None:
            to_latex_args = {}

        self.header = &#34;&#34;
        self.body = &#34;\\begin{document}\\end{document}&#34;
        self.footer = &#34;&#34;

        self.data = data
        self.to_latex_args = to_latex_args
        self.__path = path_output
        self.label = label
        self.caption = caption
        self.packages = packages

        self.paperwidth, self.paperheight = None, None
        self._get_dimensions(paperwidth, paperheight)
        self.number = number
        self.hide_numbering = hide_numbering

        self.special_char = [&#34;_&#34;, &#34;^&#34;, &#34;%&#34;, &#34;&amp;&#34;]

        if self.caption is not None:
            self.to_latex_args[&#34;caption&#34;] = self.caption
        if self.label is not None:
            self.to_latex_args[&#34;label&#34;] = self.label
        if &#34;column_format&#34; not in self.to_latex_args:
            self.to_latex_args[&#34;column_format&#34;] = &#34;|l|&#34; + len(self.data.columns) * &#34;c&#34; + &#34;|&#34;
        if &#34;escape&#34; not in self.to_latex_args:
            self.to_latex_args[&#34;escape&#34;] = True
        if &#34;longtable&#34; not in self.to_latex_args:
            self.to_latex_args[&#34;longtable&#34;] = True

        if &#34;geometry&#34; not in self.packages:
            self.packages[&#34;geometry&#34;] = {}
        if &#34;marging&#34; not in self.packages[&#34;geometry&#34;]:
            self.packages[&#34;geometry&#34;][&#34;margin&#34;] = &#34;0.5cm&#34;
        if &#34;paperwidth&#34; not in self.packages[&#34;geometry&#34;]:
            self.packages[&#34;geometry&#34;][&#34;paperwidth&#34;] = f&#34;{str(self.paperwidth)}cm&#34;
        if &#34;paperheight&#34; not in self.packages[&#34;geometry&#34;]:
            self.packages[&#34;geometry&#34;][&#34;paperheight&#34;] = f&#34;{str(self.paperheight)}cm&#34;
        if &#34;caption&#34; not in self.packages:
            self.packages[&#34;caption&#34;] = {}
        if &#34;xcolor&#34; not in self.packages:
            self.packages[&#34;xcolor&#34;] = {&#34;dvipsnames&#34;: None}
        if &#34;booktabs&#34; not in self.packages:
            self.packages[&#34;booktabs&#34;] = {}
        if &#34;inputenc&#34; not in self.packages:
            self.packages[&#34;inputenc&#34;] = {&#34;utf8&#34;: None}
        if &#34;longtable&#34; not in self.packages and self.to_latex_args[&#34;longtable&#34;] is True:
            self.packages[&#34;longtable&#34;] = {}

        if isinstance(self.number, str):
            self.number = int(self.number)
        if self.number &gt; 0:
            self.number -= 1
        self.number = str(int(self.number))

        if self.__path is not None:
            if not isinstance(self.__path, Path):
                self.__path = Path(self.__path)
            if self.__path.suffix != &#34;.tex&#34;:
                self.__path = self.__path.with_suffix(&#34;.tex&#34;)

    @property
    def path(self) -&gt; Path:
        return self.__path

    @property
    def path_output(self) -&gt; Path:
        return self.__path

    @path.setter
    def path(self, apath: Union[str, Path, None]):
        if apath is not None:
            if not isinstance(apath, Path):
                apath = Path(apath)
            if apath.suffix != &#34;.tex&#34;:
                apath = apath.with_suffix(&#34;.tex&#34;)
        self.__path = apath

    @path_output.setter
    def path_output(self, apath: Union[str, Path, None]):
        self.path = apath

    # ////////////
    # // Makers //
    # ////////////

    def _get_dimensions(self, paperwidth, paperheight):

        self.paperwidth = paperwidth
        self.paperheight = paperheight

        if self.paperwidth != 0 and self.paperheight != 0:
            return

        # Try to guess a kind of optimal width for the table
        if not self.data.empty:
            charswidth = (
                len(&#34;&#34;.join(list(self.data.columns.dropna().astype(str))))
                + max([len(ind) for ind in self.data.index.dropna().astype(str)])
            ) * 0.178
            self.paperwidth = charswidth + 0.8 * (len(self.data.columns)) + 1
            if self.paperwidth &lt; 9:
                self.paperwidth = 9
        # Same for height
        if not self.data.empty:
            self.paperheight = 3.5 + (len(self.data.index)) * 0.45
            if self.paperheight &lt; 4:
                self.paperheight = 4
            if self.paperheight &gt; 24:
                # Limit page height to A4&#39;s 24 cm
                self.paperheight = 24
                self.to_latex_args[&#34;longtable&#34;] = True
            else:
                self.to_latex_args[&#34;longtable&#34;] = False

    def _make_header(self) -&gt; None:
        &#34;&#34;&#34;Makes the header of the tex file.&#34;&#34;&#34;

        self.header = &#34;\\documentclass{article}\n&#34;

        # Add specified packages if any
        for p in self.packages:
            if len(self.packages[p]) == 0:
                self.header += p.join([&#34;\\usepackage{&#34;, &#34;}\n&#34;])
            else:
                self.header += &#34;\\usepackage[&#34;
                for o in self.packages[p]:
                    if self.packages[p][o] is None:
                        self.header += o + &#34;,&#34;

                    else:
                        self.header += o + &#34;=&#34; + self.packages[p][o] + &#34;,&#34;
                self.header = self.header[:-1] + &#34;]{&#34; + p + &#34;}\n&#34;
        self.header += &#34;\\begin{document}\n\\nonstopmode\n\\setcounter{table}{&#34; + self.number + &#34;}\n&#34;

    def _make_body(self) -&gt; None:
        &#34;&#34;&#34;Makes the main body of tex file.&#34;&#34;&#34;

        # Needed if you do not want long names to be truncated with &#34;...&#34;
        # by pandas, giving bullshit results in the .tex file
        def_max_col = pd.get_option(&#34;display.max_colwidth&#34;)
        if pd.__version__.split(&#34;.&#34;)[0] == &#34;0&#34;:
            # pandas is older than 1.0.0
            pd.set_option(&#34;display.max_colwidth&#34;, -1)
        else:
            # pandas is 1.0.0 or newer
            pd.set_option(&#34;display.max_colwidth&#34;, None)

        if self.data.empty:
            self.body = self.caption + &#34;: Empty Dataframe\n&#34;
            return
        else:
            self.body = self.data.to_latex(**self.to_latex_args)
        pd.set_option(&#34;display.max_colwidth&#34;, def_max_col)

        if self.caption is not None and self.hide_numbering:
            self.body = self.body.replace(&#34;\\caption{&#34;, &#34;\\caption*{&#34;)

        if self.caption is not None or self.label is not None:
            self.body = self.body.replace(&#34;\n\\toprule&#34;, &#34;\\\\\n\\toprule&#34;)
        self.body = self.body.replace(&#34;\\\\\\\\&#34;, &#34;\\\\&#34;)

    def _make_footer(self) -&gt; None:
        &#34;&#34;&#34;Makes the footer of tex file.&#34;&#34;&#34;

        self.footer = &#34;\\end{document}\n&#34;

    def _escape_special_chars(self, s: T) -&gt; T:
        &#34;&#34;&#34;Will add &#39;\\&#39; before special characters outside of mathmode to given
        string.

        Parameters
        ----------
        s: T
            If s is not a string, will return it without changing anything

        Returns
        -------
        T
            String with special char escaped, or unmodified non-string object
        &#34;&#34;&#34;

        if not isinstance(s, str):
            return s
        in_math = False
        previous_c = &#34;&#34;
        s2 = &#34;&#34;
        for c in s:
            if c == &#34;$&#34;:
                in_math = not in_math
            if in_math:
                s2 += c
                previous_c = c
                continue
            if c in self.special_char and not previous_c == &#34;\\&#34;:
                c = &#34;\\&#34; + c
            previous_c = c
            s2 += c
        return s2

    # //////////////////
    # // Output files //
    # //////////////////

    def build(self):
        &#34;&#34;&#34;build header body and footer.&#34;&#34;&#34;
        if &#34;escape&#34; in self.to_latex_args and self.to_latex_args[&#34;escape&#34;]:
            self.data.index = [self._escape_special_chars(s) for s in self.data.index]
            self.data.columns = [self._escape_special_chars(s) for s in self.data.columns]
            self.data = self.data.applymap(self._escape_special_chars)
        self.to_latex_args[&#34;escape&#34;] = False
        self._make_header()
        self._make_body()
        self._make_footer()

    def create_tex_file(self) -&gt; None:
        &#34;&#34;&#34;Creates the tex file.&#34;&#34;&#34;

        with open(self.__path, &#34;w&#34;) as outfile:
            # escape argument only works on column names. We need to apply
            # it on entier DataFrame, so do that then set it to False
            self.build()
            outfile.write(self.header)
            outfile.write(self.body)
            outfile.write(self.footer)

    # noinspection StandardShellInjection
    def compile(
        self, silenced: bool = True, recreate: bool = True, clean: bool = True, clean_tex: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Compile the pdf.

        Parameters
        ----------
        silenced: bool
            Will or will not print on terminal the pdflatex output. (Default value = True)
        recreate: bool
            If False and .tex file exists, compile from it. If True, recreate the .tex file first.
        clean: bool
            Removes all files created by the compilation which are not the .tex or the .pdf file.
        clean_tex: bool
            Also removes the .tex file, leaving only the .pdf.

        Returns
        -------
        None
        &#34;&#34;&#34;

        if self.__path is None:
            raise ValueError(&#34;Must specify a file path.&#34;)
        if recreate or not self.__path.is_file():
            self.create_tex_file()

        if not self.__path.is_file():
            raise ValueError(f&#34;Tex file {self.__path} not found.&#34;)

        path_to_compile = self.__path
        if self.__path.fs_kind == &#34;gcs&#34;:
            path_to_compile = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.tex&#34;)
            path_to_compile.close()
            self.__path.get(path_to_compile.name)
            path_to_compile = Path(path_to_compile.name, fs=&#34;local&#34;)

        command = &#34;pdflatex -synctex=1 -interaction=nonstopmode &#34;
        parent = path_to_compile.parent
        if parent != &#34;.&#34;:
            command = f&#34;{command} -output-directory=\&#34;{parent}\&#34;&#34;

        command = f&#34;{command} \&#34;{path_to_compile}\&#34;&#34;
        if silenced:  # unix
            if os.name == &#34;posix&#34;:
                command = f&#34;{command} &gt; /dev/null&#34;
            else:  # windows
                command = f&#34;{command} &gt; NUL&#34;
        x1 = os.system(command)
        time.sleep(0.5)
        x2 = os.system(command)
        time.sleep(0.5)
        x3 = os.system(command)

        if self.__path.fs_kind == &#34;gcs&#34;:
            for path in path_to_compile.with_suffix(&#34;&#34;).glob(&#34;*&#34;):
                path_gcs = self.__path.with_suffix(path.suffix)
                path.put(path_gcs)
                path.rm()

        if x1 != 0 or x2 != 0 or x3 != 0:
            raise ValueError(&#34;Failed to compile pdf&#34;)

        if clean:
            self.clean(clean_tex)

    def clean(self, clean_tex: bool = False) -&gt; None:
        &#34;&#34;&#34;Clean files produced by latex. Also remove .tex if clean_tex is
        True.

        Parameters
        ---------
        clean_tex: bool
            To also remove the .tex file

        Returns
        -------
        None
        &#34;&#34;&#34;
        to_keep = [&#34;.pdf&#34;, &#34;.csv&#34;, &#34;.excel&#34;]
        if not clean_tex:
            to_keep.append(&#34;.tex&#34;)
        files = self.__path.with_suffix(&#34;&#34;).glob(&#34;*&#34;)
        for f in files:
            if f.suffix not in to_keep:
                f.rm()</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="tablewriter.tablewriter.TableWriter.path"><code class="name">var <span class="ident">path</span> : transparentpath.gcsutils.transparentpath.TransparentPath</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path(self) -&gt; Path:
    return self.__path</code></pre>
</details>
</dd>
<dt id="tablewriter.tablewriter.TableWriter.path_output"><code class="name">var <span class="ident">path_output</span> : transparentpath.gcsutils.transparentpath.TransparentPath</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def path_output(self) -&gt; Path:
    return self.__path</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="tablewriter.tablewriter.TableWriter.build"><code class="name flex">
<span>def <span class="ident">build</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>build header body and footer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build(self):
    &#34;&#34;&#34;build header body and footer.&#34;&#34;&#34;
    if &#34;escape&#34; in self.to_latex_args and self.to_latex_args[&#34;escape&#34;]:
        self.data.index = [self._escape_special_chars(s) for s in self.data.index]
        self.data.columns = [self._escape_special_chars(s) for s in self.data.columns]
        self.data = self.data.applymap(self._escape_special_chars)
    self.to_latex_args[&#34;escape&#34;] = False
    self._make_header()
    self._make_body()
    self._make_footer()</code></pre>
</details>
</dd>
<dt id="tablewriter.tablewriter.TableWriter.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, clean_tex: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Clean files produced by latex. Also remove .tex if clean_tex is
True.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>clean_tex</code></strong> :&ensp;<code>bool</code></dt>
<dd>To also remove the .tex file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, clean_tex: bool = False) -&gt; None:
    &#34;&#34;&#34;Clean files produced by latex. Also remove .tex if clean_tex is
    True.

    Parameters
    ---------
    clean_tex: bool
        To also remove the .tex file

    Returns
    -------
    None
    &#34;&#34;&#34;
    to_keep = [&#34;.pdf&#34;, &#34;.csv&#34;, &#34;.excel&#34;]
    if not clean_tex:
        to_keep.append(&#34;.tex&#34;)
    files = self.__path.with_suffix(&#34;&#34;).glob(&#34;*&#34;)
    for f in files:
        if f.suffix not in to_keep:
            f.rm()</code></pre>
</details>
</dd>
<dt id="tablewriter.tablewriter.TableWriter.compile"><code class="name flex">
<span>def <span class="ident">compile</span></span>(<span>self, silenced: bool = True, recreate: bool = True, clean: bool = True, clean_tex: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Compile the pdf.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>silenced</code></strong> :&ensp;<code>bool</code></dt>
<dd>Will or will not print on terminal the pdflatex output. (Default value = True)</dd>
<dt><strong><code>recreate</code></strong> :&ensp;<code>bool</code></dt>
<dd>If False and .tex file exists, compile from it. If True, recreate the .tex file first.</dd>
<dt><strong><code>clean</code></strong> :&ensp;<code>bool</code></dt>
<dd>Removes all files created by the compilation which are not the .tex or the .pdf file.</dd>
<dt><strong><code>clean_tex</code></strong> :&ensp;<code>bool</code></dt>
<dd>Also removes the .tex file, leaving only the .pdf.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile(
    self, silenced: bool = True, recreate: bool = True, clean: bool = True, clean_tex: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Compile the pdf.

    Parameters
    ----------
    silenced: bool
        Will or will not print on terminal the pdflatex output. (Default value = True)
    recreate: bool
        If False and .tex file exists, compile from it. If True, recreate the .tex file first.
    clean: bool
        Removes all files created by the compilation which are not the .tex or the .pdf file.
    clean_tex: bool
        Also removes the .tex file, leaving only the .pdf.

    Returns
    -------
    None
    &#34;&#34;&#34;

    if self.__path is None:
        raise ValueError(&#34;Must specify a file path.&#34;)
    if recreate or not self.__path.is_file():
        self.create_tex_file()

    if not self.__path.is_file():
        raise ValueError(f&#34;Tex file {self.__path} not found.&#34;)

    path_to_compile = self.__path
    if self.__path.fs_kind == &#34;gcs&#34;:
        path_to_compile = tempfile.NamedTemporaryFile(delete=False, suffix=&#34;.tex&#34;)
        path_to_compile.close()
        self.__path.get(path_to_compile.name)
        path_to_compile = Path(path_to_compile.name, fs=&#34;local&#34;)

    command = &#34;pdflatex -synctex=1 -interaction=nonstopmode &#34;
    parent = path_to_compile.parent
    if parent != &#34;.&#34;:
        command = f&#34;{command} -output-directory=\&#34;{parent}\&#34;&#34;

    command = f&#34;{command} \&#34;{path_to_compile}\&#34;&#34;
    if silenced:  # unix
        if os.name == &#34;posix&#34;:
            command = f&#34;{command} &gt; /dev/null&#34;
        else:  # windows
            command = f&#34;{command} &gt; NUL&#34;
    x1 = os.system(command)
    time.sleep(0.5)
    x2 = os.system(command)
    time.sleep(0.5)
    x3 = os.system(command)

    if self.__path.fs_kind == &#34;gcs&#34;:
        for path in path_to_compile.with_suffix(&#34;&#34;).glob(&#34;*&#34;):
            path_gcs = self.__path.with_suffix(path.suffix)
            path.put(path_gcs)
            path.rm()

    if x1 != 0 or x2 != 0 or x3 != 0:
        raise ValueError(&#34;Failed to compile pdf&#34;)

    if clean:
        self.clean(clean_tex)</code></pre>
</details>
</dd>
<dt id="tablewriter.tablewriter.TableWriter.create_tex_file"><code class="name flex">
<span>def <span class="ident">create_tex_file</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the tex file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tex_file(self) -&gt; None:
    &#34;&#34;&#34;Creates the tex file.&#34;&#34;&#34;

    with open(self.__path, &#34;w&#34;) as outfile:
        # escape argument only works on column names. We need to apply
        # it on entier DataFrame, so do that then set it to False
        self.build()
        outfile.write(self.header)
        outfile.write(self.body)
        outfile.write(self.footer)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tablewriter" href="index.html">tablewriter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tablewriter.tablewriter.remove_color" href="#tablewriter.tablewriter.remove_color">remove_color</a></code></li>
<li><code><a title="tablewriter.tablewriter.set_color" href="#tablewriter.tablewriter.set_color">set_color</a></code></li>
<li><code><a title="tablewriter.tablewriter.set_color_dataframe" href="#tablewriter.tablewriter.set_color_dataframe">set_color_dataframe</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="tablewriter.tablewriter.TableWriter" href="#tablewriter.tablewriter.TableWriter">TableWriter</a></code></h4>
<ul class="two-column">
<li><code><a title="tablewriter.tablewriter.TableWriter.build" href="#tablewriter.tablewriter.TableWriter.build">build</a></code></li>
<li><code><a title="tablewriter.tablewriter.TableWriter.clean" href="#tablewriter.tablewriter.TableWriter.clean">clean</a></code></li>
<li><code><a title="tablewriter.tablewriter.TableWriter.compile" href="#tablewriter.tablewriter.TableWriter.compile">compile</a></code></li>
<li><code><a title="tablewriter.tablewriter.TableWriter.create_tex_file" href="#tablewriter.tablewriter.TableWriter.create_tex_file">create_tex_file</a></code></li>
<li><code><a title="tablewriter.tablewriter.TableWriter.path" href="#tablewriter.tablewriter.TableWriter.path">path</a></code></li>
<li><code><a title="tablewriter.tablewriter.TableWriter.path_output" href="#tablewriter.tablewriter.TableWriter.path_output">path_output</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>