# -*- coding: utf-8 -*-

"""
    apimaticcalculatorlatest

    This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
"""

from apimaticcalculatorlatest.api_helper import APIHelper
from apimaticcalculatorlatest.configuration import Configuration
from apimaticcalculatorlatest.controllers.base_controller import BaseController
from apimaticcalculatorlatest.http.auth.custom_query_auth import CustomQueryAuth
from apimaticcalculatorlatest.models.getmessagelistforspecificthread_response import GetmessagelistforspecificthreadResponse
from apimaticcalculatorlatest.models.getmessagethreads_response import GetmessagethreadsResponse
from apimaticcalculatorlatest.models.api_responsewithout_data import APIResponsewithoutData

class TestingOfMessageAPICallsController(BaseController):

    """A Controller to access Endpoints in the apimaticcalculatorlatest API."""


    def get_testmessagelistforspecificthread(self,
                                             thread_id):
        """Does a GET request to /messageTest/specificthread/{threadId}.

        Since API calls for messages depend on channel connections and these
        values will exist in BookingPal only if guests on channel create some
        message, these calls can work only on production. So for testing
        purposes, we’ve built an additional endpoint with the same API calls
        where you will be able to test these calls.
        This function allows the logged-in user to get a list of all messages
        from passed thread Id. You need to use PM credentials
        Note: To be able to test these calls, you need to have at least 1
        property, since we will in response return you messages for 1 property
        from your PM.

        Args:
            thread_id (string): ID of thread

        Returns:
            GetmessagelistforspecificthreadResponse: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/messageTest/specificthread/{threadId}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'threadId': thread_id
        })
        _query_builder = Configuration.base_uri
        _query_builder += _url_path
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomQueryAuth.apply(_request)
        _context = self.execute_request(_request)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, GetmessagelistforspecificthreadResponse.from_dictionary)

    def get_testmessagethreads(self,
                               page,
                               limit,
                               thread_type):
        """Does a GET request to /messageTest/allthreads/{threadType}.

        This function allows the logged in user to get all message threads or
        message threads with an unresponded message from guest for the whole
        PM. You need to use PM credentials. There is also paging as optional
        values. If you do not pass this value, we will return the first page
        and 10 threads per page.
        Since API calls for messages depend on channel connections and these
        values will exist in BookingPal only if guests on channel create some
        message, these calls can work only on production. So for testing
        purposes we’ve  built an additional endpoint with the same API calls
        where you will be able to test these calls.
        Note: To be able to test these calls, you need to have at least 1
        property, since we will in response return you messages for 1 property
        from your PM.

        Args:
            page (int): TODO: type description here. Example: 
            limit (int): TODO: type description here. Example: 
            thread_type (string): Request all threads or only threads with
                unanswered message {new,all}

        Returns:
            GetmessagethreadsResponse: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/messageTest/allthreads/{threadType}'
        _url_path = APIHelper.append_url_with_template_parameters(_url_path, { 
            'threadType': thread_type
        })
        _query_builder = Configuration.base_uri
        _query_builder += _url_path
        _query_parameters = {
            'page': page,
            'limit': limit
        }
        _query_builder = APIHelper.append_url_with_query_parameters(_query_builder,
            _query_parameters, Configuration.array_serialization)
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json'
        }

        # Prepare and execute request
        _request = self.http_client.get(_query_url, headers=_headers)
        CustomQueryAuth.apply(_request)
        _context = self.execute_request(_request)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, GetmessagethreadsResponse.from_dictionary)

    def postnew_testmessageforspecificthread(self,
                                             body):
        """Does a POST request to /messageTest.

        This function will allow PM to post new messages in already existing
        threads. Since this call is only for testing - we will not actually
        save these passed values.
        Since API calls for messages depend on channel connections and these
        values will exist in BookingPal only if guests on channel create some
        message, these calls can work only on production. So for testing
        purposes, we’ve built an additional endpoint with the same API calls
        where you will be able to test these calls.
        Note: To be able to test these calls, you need to have at least 1
        property, since we will in response return to you messages for 1
        property from your PM.

        Args:
            body (PostnewmessageforspecificthreadRequest): TODO: type
                description here. Example: 

        Returns:
            APIResponsewithoutData: Response from the API. 

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        # Prepare query URL
        _url_path = '/messageTest'
        _query_builder = Configuration.base_uri
        _query_builder += _url_path
        _query_url = APIHelper.clean_url(_query_builder)

        # Prepare headers
        _headers = {
            'accept': 'application/json',
            'content-type': 'application/json; charset=utf-8'
        }

        # Prepare and execute request
        _request = self.http_client.post(_query_url, headers=_headers, parameters=APIHelper.json_serialize(body))
        CustomQueryAuth.apply(_request)
        _context = self.execute_request(_request)
        self.validate_response(_context)

        # Return appropriate type
        return APIHelper.json_deserialize(_context.response.raw_body, APIResponsewithoutData.from_dictionary)
