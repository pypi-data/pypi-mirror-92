#

"""
    Python Insight API

    This is an internal REST API between Python and Mosel  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech

    (c) 2020 Fair Isaac Corporation
"""


from __future__ import absolute_import

import re  #

#
import six

from xpressinsight.rest.api_client import ApiClient
from xpressinsight.rest.exceptions import (
    ApiTypeError,
    ApiValueError
)


class DefaultApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def app_attachment_get(self, filename, **kwargs):  #
        """Retrieves an app attachment from the Insight server, placing it in the Mosel working directory where it can be read by the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_attachment_get(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be retrieved (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.app_attachment_get_with_http_info(filename, **kwargs)  #

    def app_attachment_get_with_http_info(self, filename, **kwargs):  #
        """Retrieves an app attachment from the Insight server, placing it in the Mosel working directory where it can be read by the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_attachment_get_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be retrieved (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method app_attachment_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `app_attachment_get`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/app/attachment/get', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def app_attachment_info_get(self, filename, **kwargs):  #
        """Retrieves information about a given app attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_attachment_info_get(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the app attachment to request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.app_attachment_info_get_with_http_info(filename, **kwargs)  #

    def app_attachment_info_get_with_http_info(self, filename, **kwargs):  #
        """Retrieves information about a given app attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_attachment_info_get_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the app attachment to request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method app_attachment_info_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `app_attachment_info_get`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/app/attachment/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def app_attachments_list_get(self, tag, **kwargs):  #
        """Retrieves a list of all the files attached to the app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_attachments_list_get(tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tag: The tag to search for (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.app_attachments_list_get_with_http_info(tag, **kwargs)  #

    def app_attachments_list_get_with_http_info(self, tag, **kwargs):  #
        """Retrieves a list of all the files attached to the app  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_attachments_list_get_with_http_info(tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tag: The tag to search for (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tag']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method app_attachments_list_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('tag' not in local_var_params or  #
                                                        local_var_params['tag'] is None):  #
            raise ApiValueError("Missing the required parameter `tag` when calling `app_attachments_list_get`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'tag' in local_var_params and local_var_params['tag'] is not None:  #
            query_params.append(('tag', local_var_params['tag']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/app/attachments/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def app_id_get(self, **kwargs):  #
        """Query the id of the Xpress Insight application which is the parent of the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_id_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.app_id_get_with_http_info(**kwargs)  #

    def app_id_get_with_http_info(self, **kwargs):  #
        """Query the id of the Xpress Insight application which is the parent of the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_id_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method app_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/app/id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def app_name_get(self, **kwargs):  #
        """Query the name of the Xpress Insight application which is the parent of the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_name_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.app_name_get_with_http_info(**kwargs)  #

    def app_name_get_with_http_info(self, **kwargs):  #
        """Query the name of the Xpress Insight application which is the parent of the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.app_name_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method app_name_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/app/name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attachments_rules_get(self, **kwargs):  #
        """Retrieves the the 'rules' used to validate attachments and attachment meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attachments_rules_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachmentRules
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.attachments_rules_get_with_http_info(**kwargs)  #

    def attachments_rules_get_with_http_info(self, **kwargs):  #
        """Retrieves the the 'rules' used to validate attachments and attachment meta-data  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attachments_rules_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachmentRules, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attachments_rules_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/attachments/rules', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachmentRules',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attachments_tags_bytag_get(self, tag, **kwargs):  #
        """Searches the scenario and the containing app for an attachment or attachments with the given tag, and retrieves them from the Insight server  # noqa: E501

        Searches the scenario and the containing app for an attachment or attachments with the given tag, and retrieves them from the Insight server, placing them in the Mosel working directory where they can be read by the model. If any scenario attachments with the given tag are found, these are retrieved without searching the app. If no scenario attachments with the given tag are found, then the search continues at the app level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attachments_tags_bytag_get(tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tag: The tag to search for (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.attachments_tags_bytag_get_with_http_info(tag, **kwargs)  #

    def attachments_tags_bytag_get_with_http_info(self, tag, **kwargs):  #
        """Searches the scenario and the containing app for an attachment or attachments with the given tag, and retrieves them from the Insight server  # noqa: E501

        Searches the scenario and the containing app for an attachment or attachments with the given tag, and retrieves them from the Insight server, placing them in the Mosel working directory where they can be read by the model. If any scenario attachments with the given tag are found, these are retrieved without searching the app. If no scenario attachments with the given tag are found, then the search continues at the app level.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attachments_tags_bytag_get_with_http_info(tag, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tag: The tag to search for (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tag']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attachments_tags_bytag_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('tag' not in local_var_params or  #
                                                        local_var_params['tag'] is None):  #
            raise ApiValueError("Missing the required parameter `tag` when calling `attachments_tags_bytag_get`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'tag' in local_var_params and local_var_params['tag'] is not None:  #
            query_params.append(('tag', local_var_params['tag']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/attachments', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def attachments_tags_get(self, **kwargs):  #
        """Retrieves a list of the attachment tags defined in the companion file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attachments_tags_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.attachments_tags_get_with_http_info(**kwargs)  #

    def attachments_tags_get_with_http_info(self, **kwargs):  #
        """Retrieves a list of the attachment tags defined in the companion file  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.attachments_tags_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method attachments_tags_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/attachments/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def mode_get(self, **kwargs):  #
        """Query the Execution Mode in which Xpress Insight is running the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mode_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.mode_get_with_http_info(**kwargs)  #

    def mode_get_with_http_info(self, **kwargs):  #
        """Query the Execution Mode in which Xpress Insight is running the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.mode_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method mode_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/mode', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def progress_reset(self, **kwargs):  #
        """Resets the progress state for each progress metric back to zero  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress_reset(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.progress_reset_with_http_info(**kwargs)  #

    def progress_reset_with_http_info(self, **kwargs):  #
        """Resets the progress state for each progress metric back to zero  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress_reset_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method progress_reset" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/progress/reset', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def progress_update(self, metric, **kwargs):  #
        """Sends update notifications for all supported progress metrics to the Xpress Insight system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress_update(metric, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int metric: The type of metric to update (required)
        :param float value: The value of the metric
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.progress_update_with_http_info(metric, **kwargs)  #

    def progress_update_with_http_info(self, metric, **kwargs):  #
        """Sends update notifications for all supported progress metrics to the Xpress Insight system  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.progress_update_with_http_info(metric, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int metric: The type of metric to update (required)
        :param float value: The value of the metric
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['metric', 'value']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method progress_update" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('metric' not in local_var_params or  #
                                                        local_var_params['metric'] is None):  #
            raise ApiValueError("Missing the required parameter `metric` when calling `progress_update`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'metric' in local_var_params and local_var_params['metric'] is not None:  #
            query_params.append(('metric', local_var_params['metric']))  #
        if 'value' in local_var_params and local_var_params['value'] is not None:  #
            query_params.append(('value', local_var_params['value']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/progress/update', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_delete(self, filename, **kwargs):  #
        """Deletes a scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_delete(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be deleted (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_delete_with_http_info(filename, **kwargs)  #

    def scenario_attachment_delete_with_http_info(self, filename, **kwargs):  #
        """Deletes a scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_delete_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be deleted (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_delete`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/delete', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_description_put(self, filename, **kwargs):  #
        """Update the description of an existing scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_description_put(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to request (required)
        :param str description: The new description of the attachment
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_description_put_with_http_info(filename, **kwargs)  #

    def scenario_attachment_description_put_with_http_info(self, filename, **kwargs):  #
        """Update the description of an existing scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_description_put_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to request (required)
        :param str description: The new description of the attachment
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename', 'description']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_description_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_description_put`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #
        if 'description' in local_var_params and local_var_params['description'] is not None:  #
            query_params.append(('description', local_var_params['description']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/set/description', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_get(self, filename, **kwargs):  #
        """Retrieves an attachment from the Insight server either for a given scenario, placing it in the Mosel working directory where it can be read by the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_get(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be retrieved (required)
        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_get_with_http_info(filename, **kwargs)  #

    def scenario_attachment_get_with_http_info(self, filename, **kwargs):  #
        """Retrieves an attachment from the Insight server either for a given scenario, placing it in the Mosel working directory where it can be read by the model  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_get_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be retrieved (required)
        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename', 'scenariopath']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_get`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #
        if 'scenariopath' in local_var_params and local_var_params['scenariopath'] is not None:  #
            query_params.append(('scenariopath', local_var_params['scenariopath']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/get', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_hidden_put(self, filename, **kwargs):  #
        """Mark an existing scenario attachment as hidden or visible in the Xpress Insight UI  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_hidden_put(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to hide or show (required)
        :param bool hidden: If true, the attachment will be hidden in the Xpress Insight UI; if false, it will be visible
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_hidden_put_with_http_info(filename, **kwargs)  #

    def scenario_attachment_hidden_put_with_http_info(self, filename, **kwargs):  #
        """Mark an existing scenario attachment as hidden or visible in the Xpress Insight UI  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_hidden_put_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to hide or show (required)
        :param bool hidden: If true, the attachment will be hidden in the Xpress Insight UI; if false, it will be visible
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename', 'hidden']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_hidden_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_hidden_put`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #
        if 'hidden' in local_var_params and local_var_params['hidden'] is not None:  #
            query_params.append(('hidden', local_var_params['hidden']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/set/hidden', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_info_get(self, filename, **kwargs):  #
        """Retrieves information about a given scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_info_get(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to request (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_info_get_with_http_info(filename, **kwargs)  #

    def scenario_attachment_info_get_with_http_info(self, filename, **kwargs):  #
        """Retrieves information about a given scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_info_get_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to request (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_info_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_info_get`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/info', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_put(self, filename, overwrite, **kwargs):  #
        """Uploads a scenario attachment to the Insight server, reading it from the Mosel working directory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_put(filename, overwrite, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be deleted (required)
        :param bool overwrite: If true, will overwrite attachment if it already exists. If false and attachment already exists, will fail with insightattachstatus INSIGHT_ATTACH_ALREADY_EXISTS. Defaults to true if not given. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_put_with_http_info(filename, overwrite, **kwargs)  #

    def scenario_attachment_put_with_http_info(self, filename, overwrite, **kwargs):  #
        """Uploads a scenario attachment to the Insight server, reading it from the Mosel working directory  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_put_with_http_info(filename, overwrite, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the attachment to be deleted (required)
        :param bool overwrite: If true, will overwrite attachment if it already exists. If false and attachment already exists, will fail with insightattachstatus INSIGHT_ATTACH_ALREADY_EXISTS. Defaults to true if not given. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename', 'overwrite']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_put`")  #
        #
        if self.api_client.client_side_validation and ('overwrite' not in local_var_params or  #
                                                        local_var_params['overwrite'] is None):  #
            raise ApiValueError("Missing the required parameter `overwrite` when calling `scenario_attachment_put`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #
        if 'overwrite' in local_var_params and local_var_params['overwrite'] is not None:  #
            query_params.append(('overwrite', local_var_params['overwrite']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/put', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_rename(self, filename, newname, **kwargs):  #
        """Renames an existing scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_rename(filename, newname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The existing filename of the attachment to be renamed (required)
        :param str newname: The new filename of the attachment. Must not already be used for a scenario attachment (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_rename_with_http_info(filename, newname, **kwargs)  #

    def scenario_attachment_rename_with_http_info(self, filename, newname, **kwargs):  #
        """Renames an existing scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_rename_with_http_info(filename, newname, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The existing filename of the attachment to be renamed (required)
        :param str newname: The new filename of the attachment. Must not already be used for a scenario attachment (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename', 'newname']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_rename" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_rename`")  #
        #
        if self.api_client.client_side_validation and ('newname' not in local_var_params or  #
                                                        local_var_params['newname'] is None):  #
            raise ApiValueError("Missing the required parameter `newname` when calling `scenario_attachment_rename`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #
        if 'newname' in local_var_params and local_var_params['newname'] is not None:  #
            query_params.append(('newname', local_var_params['newname']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/rename', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachment_tags_put(self, filename, **kwargs):  #
        """Update the tags of an existing scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_tags_put(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to update (required)
        :param list[str] tags: The new tags to apply to the attachment. Any existing tags will be removed.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AttachStatus
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachment_tags_put_with_http_info(filename, **kwargs)  #

    def scenario_attachment_tags_put_with_http_info(self, filename, **kwargs):  #
        """Update the tags of an existing scenario attachment  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachment_tags_put_with_http_info(filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str filename: The filename of the scenario attachment to update (required)
        :param list[str] tags: The new tags to apply to the attachment. Any existing tags will be removed.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AttachStatus, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['filename', 'tags']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachment_tags_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        #
        if self.api_client.client_side_validation and ('filename' not in local_var_params or  #
                                                        local_var_params['filename'] is None):  #
            raise ApiValueError("Missing the required parameter `filename` when calling `scenario_attachment_tags_put`")  #

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'filename' in local_var_params and local_var_params['filename'] is not None:  #
            query_params.append(('filename', local_var_params['filename']))  #
        if 'tags' in local_var_params and local_var_params['tags'] is not None:  #
            query_params.append(('tags', local_var_params['tags']))  #
            collection_formats['tags'] = 'pipe'  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachment/set/tags', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AttachStatus',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_attachments_list_get(self, **kwargs):  #
        """Retrieves a list of all the files attached to a given scenario  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachments_list_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tag: The tag to search for
        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_attachments_list_get_with_http_info(**kwargs)  #

    def scenario_attachments_list_get_with_http_info(self, **kwargs):  #
        """Retrieves a list of all the files attached to a given scenario  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_attachments_list_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str tag: The tag to search for
        :param str scenariopath: The path of a scenario. A scenario path is the full path to a scenario name starting from the repository root and including the app name. E.g. /myapp/FolderA/FolderB/myscenario If the scenario path is not specified, the attachment is retrieved for the current scenario.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(object, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['tag', 'scenariopath']  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_attachments_list_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'tag' in local_var_params and local_var_params['tag'] is not None:  #
            query_params.append(('tag', local_var_params['tag']))  #
        if 'scenariopath' in local_var_params and local_var_params['scenariopath'] is not None:  #
            query_params.append(('scenariopath', local_var_params['scenariopath']))  #

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/attachments/list', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_id_get(self, **kwargs):  #
        """The globally unique identifier string for the scenario in the Xpress-Insight repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_id_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_id_get_with_http_info(**kwargs)  #

    def scenario_id_get_with_http_info(self, **kwargs):  #
        """The globally unique identifier string for the scenario in the Xpress-Insight repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_id_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/id', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_name_get(self, **kwargs):  #
        """The name of the scenario in the Xpress-Insight repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_name_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_name_get_with_http_info(**kwargs)  #

    def scenario_name_get_with_http_info(self, **kwargs):  #
        """The name of the scenario in the Xpress-Insight repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_name_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_name_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/name', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def scenario_path_get(self, **kwargs):  #
        """The repository path of the current scenario in the Xpress-Insight repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_path_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.scenario_path_get_with_http_info(**kwargs)  #

    def scenario_path_get_with_http_info(self, **kwargs):  #
        """The repository path of the current scenario in the Xpress-Insight repository  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.scenario_path_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method scenario_path_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/scenario/path', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def username_get(self, **kwargs):  #
        """Obtains the username of the Insight user that initiated the current scenario execution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.username_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.username_get_with_http_info(**kwargs)  #

    def username_get_with_http_info(self, **kwargs):  #
        """Obtains the username of the Insight user that initiated the current scenario execution  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.username_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(str, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  #
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method username_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        #
        header_params['Accept'] = self.api_client.select_header_accept(
            ['text/plain'])  #

        #
        auth_settings = ['cookieAuth']  #

        return self.api_client.call_api(
            '/username', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  #
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  #
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
