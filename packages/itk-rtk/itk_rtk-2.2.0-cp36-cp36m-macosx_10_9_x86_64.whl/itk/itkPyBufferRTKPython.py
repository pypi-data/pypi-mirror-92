# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _RTKPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkPyBufferRTKPython
else:
    import _itkPyBufferRTKPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkPyBufferRTKPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkPyBufferRTKPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkImageRTKPython
import itk.itkIndexPython
import itk.itkSizePython
import itk.pyBasePython
import itk.itkOffsetPython
import itk.itkCovariantVectorPython
import itk.vnl_vectorPython
import itk.stdcomplexPython
import itk.vnl_matrixPython
import itk.itkFixedArrayPython
import itk.itkVectorPython
import itk.vnl_vector_refPython
import itk.itkImageBaseRTKPython
import itk.itkPointRTKPython
import itk.ITKCommonBasePython
import itk.itkMatrixRTKPython
import itk.itkCovariantVectorRTKPython
import itk.itkImageRegionRTKPython
import itk.itkImagePython
import itk.itkImageRegionPython
import itk.itkRGBAPixelPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkPointPython
import itk.itkRGBPixelPython


HAVE_NUMPY = True
try:
  import numpy as np
  class NDArrayITKBase(np.ndarray):
      """A numpy array that provides a view on the data associated with an optional itk "base" object."""

      def __new__(cls, input_array, itk_base=None):
          obj = np.asarray(input_array).view(cls)
          obj.itk_base = itk_base
          return obj

      def __array_finalize__(self, obj):
          if obj is None: return
          self.itk_base = getattr(obj, 'itk_base', None)

except ImportError:
  HAVE_NUMPY = False
try:
    import numpy as np
    from distributed.protocol import dask_serialize, dask_deserialize
    from typing import Dict, List, Tuple
except ImportError:
    pass
else:
    @dask_serialize.register(NDArrayITKBase)
    def serialize(ndarray_itk_base: NDArrayITKBase) -> Tuple[Dict, List[bytes]]:
        dumps = dask_serialize.dispatch(np.ndarray)
        return dumps(ndarray_itk_base)

    @dask_deserialize.register(NDArrayITKBase)
    def deserialize(header: Dict, frames: List[bytes]) -> NDArrayITKBase:
        loads = dask_deserialize.dispatch(np.ndarray)
        return NDArrayITKBase(loads(header, frames))

def _get_numpy_pixelid(itk_Image_type):
    """Returns a ITK PixelID given a numpy array."""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')
# This is a Mapping from numpy array types to itk pixel types.
    _np_itk = {"UC":np.uint8,
               "US":np.uint16,
               "UI":np.uint32,
               "UL":np.uint64,
               "SC":np.int8,
               "SS":np.int16,
               "SI":np.int32,
               "SL":np.int64,
               "F":np.float32,
               "D":np.float64,
                }
    import os
    if os.name == 'nt':
        _np_itk['UL'] = np.uint32
        _np_itk['SL'] = np.int32
    try:
        return _np_itk[itk_Image_type]
    except KeyError as e:
        raise e

class itkPyBufferICVF52(object):
    r"""Proxy of C++ itkPyBufferICVF52 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF52__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF52__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF52 self) -> itkPyBufferICVF52
        __init__(itkPyBufferICVF52 self, itkPyBufferICVF52 arg0) -> itkPyBufferICVF52
        """
        _itkPyBufferRTKPython.itkPyBufferICVF52_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferICVF52(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferICVF52


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF52._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF52.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF52._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF52._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF52._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF52.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF52 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferICVF52_swigregister(itkPyBufferICVF52)
itkPyBufferICVF52__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferICVF52__GetArrayViewFromImage
itkPyBufferICVF52__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferICVF52__GetImageViewFromArray

class itkPyBufferICVF53(object):
    r"""Proxy of C++ itkPyBufferICVF53 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF53__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF53__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF53 self) -> itkPyBufferICVF53
        __init__(itkPyBufferICVF53 self, itkPyBufferICVF53 arg0) -> itkPyBufferICVF53
        """
        _itkPyBufferRTKPython.itkPyBufferICVF53_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferICVF53(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferICVF53


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF53._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF53.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF53._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF53._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF53._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF53.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF53 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferICVF53_swigregister(itkPyBufferICVF53)
itkPyBufferICVF53__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferICVF53__GetArrayViewFromImage
itkPyBufferICVF53__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferICVF53__GetImageViewFromArray

class itkPyBufferID1(object):
    r"""Proxy of C++ itkPyBufferID1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferID1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferID1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferID1 self) -> itkPyBufferID1
        __init__(itkPyBufferID1 self, itkPyBufferID1 arg0) -> itkPyBufferID1
        """
        _itkPyBufferRTKPython.itkPyBufferID1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferID1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferID1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferID1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferID1_swigregister(itkPyBufferID1)
itkPyBufferID1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferID1__GetArrayViewFromImage
itkPyBufferID1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferID1__GetImageViewFromArray

class itkPyBufferIF1(object):
    r"""Proxy of C++ itkPyBufferIF1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIF1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIF1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIF1 self) -> itkPyBufferIF1
        __init__(itkPyBufferIF1 self, itkPyBufferIF1 arg0) -> itkPyBufferIF1
        """
        _itkPyBufferRTKPython.itkPyBufferIF1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIF1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIF1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIF1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIF1_swigregister(itkPyBufferIF1)
itkPyBufferIF1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIF1__GetArrayViewFromImage
itkPyBufferIF1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIF1__GetImageViewFromArray

class itkPyBufferIUC1(object):
    r"""Proxy of C++ itkPyBufferIUC1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUC1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUC1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUC1 self) -> itkPyBufferIUC1
        __init__(itkPyBufferIUC1 self, itkPyBufferIUC1 arg0) -> itkPyBufferIUC1
        """
        _itkPyBufferRTKPython.itkPyBufferIUC1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIUC1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIUC1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUC1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIUC1_swigregister(itkPyBufferIUC1)
itkPyBufferIUC1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIUC1__GetArrayViewFromImage
itkPyBufferIUC1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIUC1__GetImageViewFromArray

class itkPyBufferIUS1(object):
    r"""Proxy of C++ itkPyBufferIUS1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUS1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUS1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUS1 self) -> itkPyBufferIUS1
        __init__(itkPyBufferIUS1 self, itkPyBufferIUS1 arg0) -> itkPyBufferIUS1
        """
        _itkPyBufferRTKPython.itkPyBufferIUS1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIUS1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIUS1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUS1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIUS1_swigregister(itkPyBufferIUS1)
itkPyBufferIUS1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIUS1__GetArrayViewFromImage
itkPyBufferIUS1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIUS1__GetImageViewFromArray

class itkPyBufferIVF52(object):
    r"""Proxy of C++ itkPyBufferIVF52 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF52__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF52__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF52 self) -> itkPyBufferIVF52
        __init__(itkPyBufferIVF52 self, itkPyBufferIVF52 arg0) -> itkPyBufferIVF52
        """
        _itkPyBufferRTKPython.itkPyBufferIVF52_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIVF52(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIVF52


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF52._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF52.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF52._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF52._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF52._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF52.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF52 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIVF52_swigregister(itkPyBufferIVF52)
itkPyBufferIVF52__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIVF52__GetArrayViewFromImage
itkPyBufferIVF52__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIVF52__GetImageViewFromArray

class itkPyBufferIVF53(object):
    r"""Proxy of C++ itkPyBufferIVF53 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF53__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF53__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF53 self) -> itkPyBufferIVF53
        __init__(itkPyBufferIVF53 self, itkPyBufferIVF53 arg0) -> itkPyBufferIVF53
        """
        _itkPyBufferRTKPython.itkPyBufferIVF53_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIVF53(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIVF53


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF53._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF53.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF53._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF53._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF53._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF53.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF53 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIVF53_swigregister(itkPyBufferIVF53)
itkPyBufferIVF53__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIVF53__GetArrayViewFromImage
itkPyBufferIVF53__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIVF53__GetImageViewFromArray



