# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.


from . import _RTKPython



from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _itkPyBufferRTKPython
else:
    import _itkPyBufferRTKPython

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

_swig_new_instance_method = _itkPyBufferRTKPython.SWIG_PyInstanceMethod_New
_swig_new_static_method = _itkPyBufferRTKPython.SWIG_PyStaticMethod_New

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


import itk.itkImageRTKPython
import itk.itkCovariantVectorPython
import itk.vnl_vector_refPython
import itk.vnl_vectorPython
import itk.vnl_matrixPython
import itk.stdcomplexPython
import itk.pyBasePython
import itk.itkVectorPython
import itk.itkFixedArrayPython
import itk.itkImageBaseRTKPython
import itk.ITKCommonBasePython
import itk.itkPointRTKPython
import itk.itkImageRegionRTKPython
import itk.itkSizePython
import itk.itkIndexPython
import itk.itkOffsetPython
import itk.itkMatrixRTKPython
import itk.itkCovariantVectorRTKPython
import itk.itkImagePython
import itk.itkRGBAPixelPython
import itk.itkImageRegionPython
import itk.itkSymmetricSecondRankTensorPython
import itk.itkMatrixPython
import itk.vnl_matrix_fixedPython
import itk.itkPointPython
import itk.itkRGBPixelPython


HAVE_NUMPY = True
try:
  import numpy as np
  class NDArrayITKBase(np.ndarray):
      """A numpy array that provides a view on the data associated with an optional itk "base" object."""

      def __new__(cls, input_array, itk_base=None):
          obj = np.asarray(input_array).view(cls)
          obj.itk_base = itk_base
          return obj

      def __array_finalize__(self, obj):
          if obj is None: return
          self.itk_base = getattr(obj, 'itk_base', None)

except ImportError:
  HAVE_NUMPY = False
try:
    import numpy as np
    from distributed.protocol import dask_serialize, dask_deserialize
    from typing import Dict, List, Tuple
except ImportError:
    pass
else:
    @dask_serialize.register(NDArrayITKBase)
    def serialize(ndarray_itk_base: NDArrayITKBase) -> Tuple[Dict, List[bytes]]:
        dumps = dask_serialize.dispatch(np.ndarray)
        return dumps(ndarray_itk_base)

    @dask_deserialize.register(NDArrayITKBase)
    def deserialize(header: Dict, frames: List[bytes]) -> NDArrayITKBase:
        loads = dask_deserialize.dispatch(np.ndarray)
        return NDArrayITKBase(loads(header, frames))

def _get_numpy_pixelid(itk_Image_type):
    """Returns a ITK PixelID given a numpy array."""

    if not HAVE_NUMPY:
        raise ImportError('Numpy not available.')
# This is a Mapping from numpy array types to itk pixel types.
    _np_itk = {"UC":np.uint8,
               "US":np.uint16,
               "UI":np.uint32,
               "UL":np.uint64,
               "SC":np.int8,
               "SS":np.int16,
               "SI":np.int32,
               "SL":np.int64,
               "F":np.float32,
               "D":np.float64,
                }
    import os
    if os.name == 'nt':
        _np_itk['UL'] = np.uint32
        _np_itk['SL'] = np.int32
    try:
        return _np_itk[itk_Image_type]
    except KeyError as e:
        raise e

class itkPyBufferICVF52(object):
    r"""Proxy of C++ itkPyBufferICVF52 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF52__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF52__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF52 self) -> itkPyBufferICVF52
        __init__(itkPyBufferICVF52 self, itkPyBufferICVF52 arg0) -> itkPyBufferICVF52
        """
        _itkPyBufferRTKPython.itkPyBufferICVF52_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferICVF52(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferICVF52


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF52._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF52.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF52._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF52._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF52._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF52.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF52 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferICVF52_swigregister(itkPyBufferICVF52)
itkPyBufferICVF52__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferICVF52__GetArrayViewFromImage
itkPyBufferICVF52__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferICVF52__GetImageViewFromArray

class itkPyBufferICVF53(object):
    r"""Proxy of C++ itkPyBufferICVF53 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF53__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferICVF53__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferICVF53 self) -> itkPyBufferICVF53
        __init__(itkPyBufferICVF53 self, itkPyBufferICVF53 arg0) -> itkPyBufferICVF53
        """
        _itkPyBufferRTKPython.itkPyBufferICVF53_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferICVF53(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferICVF53


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferICVF53._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferICVF53.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferICVF53._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferICVF53._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferICVF53._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferICVF53.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferICVF53 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferICVF53_swigregister(itkPyBufferICVF53)
itkPyBufferICVF53__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferICVF53__GetArrayViewFromImage
itkPyBufferICVF53__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferICVF53__GetImageViewFromArray

class itkPyBufferID1(object):
    r"""Proxy of C++ itkPyBufferID1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferID1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferID1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferID1 self) -> itkPyBufferID1
        __init__(itkPyBufferID1 self, itkPyBufferID1 arg0) -> itkPyBufferID1
        """
        _itkPyBufferRTKPython.itkPyBufferID1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferID1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferID1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "D"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferID1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferID1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferID1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferID1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferID1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferID1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferID1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferID1_swigregister(itkPyBufferID1)
itkPyBufferID1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferID1__GetArrayViewFromImage
itkPyBufferID1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferID1__GetImageViewFromArray

class itkPyBufferIF1(object):
    r"""Proxy of C++ itkPyBufferIF1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIF1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIF1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIF1 self) -> itkPyBufferIF1
        __init__(itkPyBufferIF1 self, itkPyBufferIF1 arg0) -> itkPyBufferIF1
        """
        _itkPyBufferRTKPython.itkPyBufferIF1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIF1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIF1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIF1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIF1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIF1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIF1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIF1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIF1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIF1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIF1_swigregister(itkPyBufferIF1)
itkPyBufferIF1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIF1__GetArrayViewFromImage
itkPyBufferIF1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIF1__GetImageViewFromArray

class itkPyBufferIUC1(object):
    r"""Proxy of C++ itkPyBufferIUC1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUC1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUC1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUC1 self) -> itkPyBufferIUC1
        __init__(itkPyBufferIUC1 self, itkPyBufferIUC1 arg0) -> itkPyBufferIUC1
        """
        _itkPyBufferRTKPython.itkPyBufferIUC1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIUC1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIUC1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "UC"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUC1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUC1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUC1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUC1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUC1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUC1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUC1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIUC1_swigregister(itkPyBufferIUC1)
itkPyBufferIUC1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIUC1__GetArrayViewFromImage
itkPyBufferIUC1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIUC1__GetImageViewFromArray

class itkPyBufferIUS1(object):
    r"""Proxy of C++ itkPyBufferIUS1 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUS1__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIUS1__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIUS1 self) -> itkPyBufferIUS1
        __init__(itkPyBufferIUS1 self, itkPyBufferIUS1 arg0) -> itkPyBufferIUS1
        """
        _itkPyBufferRTKPython.itkPyBufferIUS1_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIUS1(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIUS1


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "US"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIUS1._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIUS1.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIUS1._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIUS1._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIUS1._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIUS1.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIUS1 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIUS1_swigregister(itkPyBufferIUS1)
itkPyBufferIUS1__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIUS1__GetArrayViewFromImage
itkPyBufferIUS1__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIUS1__GetImageViewFromArray

class itkPyBufferIVF52(object):
    r"""Proxy of C++ itkPyBufferIVF52 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF52__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF52__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF52 self) -> itkPyBufferIVF52
        __init__(itkPyBufferIVF52 self, itkPyBufferIVF52 arg0) -> itkPyBufferIVF52
        """
        _itkPyBufferRTKPython.itkPyBufferIVF52_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIVF52(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIVF52


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF52._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF52.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF52._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF52._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF52._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF52.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF52 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIVF52_swigregister(itkPyBufferIVF52)
itkPyBufferIVF52__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIVF52__GetArrayViewFromImage
itkPyBufferIVF52__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIVF52__GetImageViewFromArray

class itkPyBufferIVF53(object):
    r"""Proxy of C++ itkPyBufferIVF53 class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    _GetArrayViewFromImage = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF53__GetArrayViewFromImage)
    _GetImageViewFromArray = _swig_new_static_method(_itkPyBufferRTKPython.itkPyBufferIVF53__GetImageViewFromArray)

    def __init__(self, *args):
        r"""
        __init__(itkPyBufferIVF53 self) -> itkPyBufferIVF53
        __init__(itkPyBufferIVF53 self, itkPyBufferIVF53 arg0) -> itkPyBufferIVF53
        """
        _itkPyBufferRTKPython.itkPyBufferIVF53_swiginit(self, _itkPyBufferRTKPython.new_itkPyBufferIVF53(*args))
    __swig_destroy__ = _itkPyBufferRTKPython.delete_itkPyBufferIVF53


    def GetArrayViewFromImage(image, keep_axes=False, update=True):
        """Get a NumPy array view of a ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        if update:
    # Ensure the image regions and image pixel buffer have been updated
    # correctly
            source = image.GetSource()
            if source:
                source.UpdateLargestPossibleRegion()

        itksize = image.GetLargestPossibleRegion().GetSize()
        dim     = len(itksize)
        shape   = [int(itksize[idx]) for idx in range(dim)]

        if(image.GetNumberOfComponentsPerPixel() > 1):
            shape = [image.GetNumberOfComponentsPerPixel(), ] + shape

        if keep_axes == False:
            shape.reverse()

        pixelType     = "F"
        numpy_dtype = _get_numpy_pixelid(pixelType)
        memview       = itkPyBufferIVF53._GetArrayViewFromImage(image)
        ndarr_view  = np.asarray(memview).view(dtype = numpy_dtype).reshape(shape).view(np.ndarray)
        itk_view = NDArrayITKBase(ndarr_view, image)

        return itk_view

    GetArrayViewFromImage = staticmethod(GetArrayViewFromImage)

    def GetArrayFromImage(image, keep_axes=False, update=True):
        """Get a NumPy ndarray from an ITK Image.

        When *keep_axes* is *False*, the NumPy array will have C-order
        indexing. This is the reverse of how indices are specified in ITK,
        i.e. k,j,i versus i,j,k. However C-order indexing is expected by most
        algorithms in NumPy / SciPy.

        This is a deep copy of the image buffer and is completely safe and without potential side effects.
        """

        arrayView = itkPyBufferIVF53.GetArrayViewFromImage(image, keep_axes, update)

    # perform deep copy of the image buffer
        arr = np.array(arrayView, copy=True)

        return arr


    GetArrayFromImage = staticmethod(GetArrayFromImage)

    def GetImageViewFromArray(ndarr, is_vector=False):
        """Get an ITK Image view of a NumPy array.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

        if not HAVE_NUMPY:
            raise ImportError('Numpy not available.')

        assert ndarr.ndim in ( 1, 2, 3, 4 ), \
            "Only arrays of 1, 2, 3 or 4 dimensions are supported."
        if not ndarr.flags['C_CONTIGUOUS'] and not ndarr.flags['F_CONTIGUOUS']:
            ndarr = np.ascontiguousarray(ndarr)

        if ( ndarr.ndim == 3 and is_vector ) or (ndarr.ndim == 4):
            if( ndarr.flags['C_CONTIGUOUS'] ):
                imgview = itkPyBufferIVF53._GetImageViewFromArray( ndarr, ndarr.shape[-2::-1], ndarr.shape[-1] )
            else:
                imgview = itkPyBufferIVF53._GetImageViewFromArray( ndarr, ndarr.shape[-1:0:-1], ndarr.shape[0] )
        elif ndarr.ndim in ( 1, 2, 3 ):
            imgview = itkPyBufferIVF53._GetImageViewFromArray( ndarr, ndarr.shape[::-1], 1)

    # Keep a reference
        imgview._SetBase(ndarr)

        return imgview

    GetImageViewFromArray = staticmethod(GetImageViewFromArray)

    def GetImageFromArray(ndarr, is_vector=False):
        """Get an ITK Image of a NumPy array.

        This is a deep copy of the NumPy array buffer and is completely safe without potential
        side effects.

        If is_vector is True, then a 3D array will be treated as a 2D vector image,
        otherwise it will be treated as a 3D image.

        If the array uses Fortran-order indexing, i.e. i,j,k, the Image Size
        will have the same dimensions as the array shape. If the array uses
        C-order indexing, i.e. k,j,i, the image Size will have the dimensions
        reversed from the array shape.

        Therefore, since the *np.transpose* operator on a 2D array simply
        inverts the indexing scheme, the Image representation will be the
        same for an array and its transpose. If flipping is desired, see
        *np.reshape*.
        """

    # Create a temporary image view of the array
        imageView = itkPyBufferIVF53.GetImageViewFromArray(ndarr, is_vector)

    # Duplicate the image to let it manage its own memory buffer
        import itk
        duplicator = itk.ImageDuplicator.New(imageView)
        duplicator.Update()
        return duplicator.GetOutput()

    GetImageFromArray = staticmethod(GetImageFromArray)



# Register itkPyBufferIVF53 in _itkPyBufferRTKPython:
_itkPyBufferRTKPython.itkPyBufferIVF53_swigregister(itkPyBufferIVF53)
itkPyBufferIVF53__GetArrayViewFromImage = _itkPyBufferRTKPython.itkPyBufferIVF53__GetArrayViewFromImage
itkPyBufferIVF53__GetImageViewFromArray = _itkPyBufferRTKPython.itkPyBufferIVF53__GetImageViewFromArray



